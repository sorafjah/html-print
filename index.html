<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ルビふりお2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @media print {
            body * { visibility: hidden; }
            #preview-container, #preview-container * { visibility: visible; }
            #preview-container { position: absolute; left: 0; top: 0; width: 100%; margin: 0; padding: 0; box-shadow: none; background: white; }
            ruby { ruby-position: over; }
        }
        .preview-content {
            font-family: "BIZ UDPGothic","BIZ UDGothic","Hiragino Kaku Gothic ProN","Hiragino Sans","Meiryo","Yu Gothic",sans-serif;
            line-height: 2.0; overflow-wrap: break-word; font-size: 12pt;
        }
        .page-hp { width: 100%; padding: 2rem; background: white; min-height: 100%; }

        /* ルビ編集モード */
        .ruby-edit-mode ruby {
            display: inline-ruby; position: relative; cursor: pointer;
            border-radius: 4px; background-color: transparent; border-bottom: 1px dotted #ccc;
        }
        .ruby-edit-mode ruby:hover { background-color: #e0f2fe; }
        .ruby-edit-mode ruby.editing-active { background-color: #fce7f3; outline: 2px solid #ec4899; z-index: 10; }

        /* ふりがなのない漢字のハイライト */
        .ruby-edit-mode .kanji-no-ruby {
            cursor: pointer; border-bottom: 2px dashed #f59e0b;
            background-color: #fffbeb; border-radius: 2px; position: relative;
        }
        .ruby-edit-mode .kanji-no-ruby:hover { background-color: #fef3c7; }

        rt { display: ruby-text; font-size: 0.5em; line-height: 1; text-align: center; color: #555; user-select: none; }
        #preview-container table { border-collapse: collapse; margin: 0.5em 0; }
        #preview-container th, #preview-container td { border: 1px solid #999; padding: 4px 8px; }
        #preview-container th { background: #f3f4f6; font-weight: bold; }
        #web-iframe { width: 100%; height: 100%; border: none; background: white; }

        /* モードボタン統一デザイン（WEBプレビュー色で統一） */
        .mode-btn {
            padding: 4px 14px; border-radius: 9999px; font-size: 0.75rem;
            font-weight: bold; cursor: pointer; transition: all 0.15s;
        }
        .mode-btn.active { background: #3b82f6; color: white; }
        .mode-btn:not(.active) { background: #e5e7eb; color: #374151; }
        .mode-btn:not(.active):hover { background: #d1d5db; }

        .text-edit-mode { cursor: text; outline: none; }
        .text-edit-mode:focus { outline: none; }
        .text-edit-mode ruby { cursor: text !important; border-bottom: none !important; }
        .text-edit-mode ruby:hover { background-color: transparent !important; }

        /* エディタ→プレビュー ハイライト */
        .editor-highlight { background-color: #fef08a !important; border-radius: 2px; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

<!-- ヘッダー -->
<header class="bg-white shadow-sm z-10 p-3 flex items-center shrink-0" style="min-height:52px">
    <h1 class="text-xl font-bold text-gray-700 shrink-0 mr-4" style="width:160px">ルビふりお2</h1>
    <div class="flex gap-2 ml-auto">
        <button onclick="openInNewTab()" class="bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-1.5 rounded text-sm transition">
            WEBサイトで表示
        </button>
        <button onclick="copyHtml()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-1.5 rounded text-sm transition">
            <i class="fas fa-code mr-1"></i> HTMLコピー
        </button>
    </div>
</header>

<!-- ツールバー -->
<div class="bg-white border-b border-gray-200 p-2 flex flex-wrap gap-3 items-center shrink-0 text-sm">
    <div class="flex items-center border-r pr-3 gap-2">
        <span class="text-gray-500 text-xs font-bold uppercase">全体サイズ</span>
        <div class="flex items-center">
            <input type="number" id="base-font-size" value="12" min="6" max="72" class="w-14 border border-gray-300 rounded p-1 text-center" onchange="updateBaseFontSize()">
            <span class="ml-1 text-gray-600 text-xs">pt</span>
            <div class="flex flex-col ml-1 gap-0.5">
                <button onmousedown="event.preventDefault()" onclick="stepFontSize(1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▲</button>
                <button onmousedown="event.preventDefault()" onclick="stepFontSize(-1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▼</button>
            </div>
        </div>
    </div>
    <div class="flex items-center border-r pr-3 gap-1">
        <select id="font-family-select" onchange="wrapFontFamily(this.value); this.value='';" class="border border-gray-300 rounded p-1 w-24 mr-1 text-xs">
            <option value="" disabled selected>フォント</option>
            <option value="">デフォルト(UD)</option>
            <option value="'UD Digi Kyokasho','YuKyokasho','Kaisho',serif">教科書体</option>
            <option value="'HiraMinProN-W3','YuMincho','MS PMincho',serif">明朝体</option>
            <option value="'Hiragino Kaku Gothic ProN','YuGothic','MS PGothic',sans-serif">ゴシック</option>
            <option value="'Hiragino Maru Gothic ProN','HGMaruGothicMPRO','Rounded Mplus 1c',sans-serif">丸ゴシック</option>
        </select>
        <button onmousedown="event.preventDefault()" onclick="wrapSelection('b')" class="p-1.5 hover:bg-gray-100 rounded" title="太字"><i class="fas fa-bold"></i></button>
        <button onmousedown="event.preventDefault()" onclick="wrapColor('red')" class="p-1.5 hover:bg-gray-100 rounded text-red-500" title="赤文字"><i class="fas fa-font"></i></button>
    </div>
    <div class="flex items-center border border-gray-300 rounded px-1 bg-gray-50">
        <span class="text-[10px] text-gray-500 mr-1 font-bold">選択文字</span>
        <input type="number" id="sel-font-size" value="16" class="w-10 p-0.5 text-center text-xs border-none bg-transparent focus:ring-0 outline-none">
        <span class="text-[10px] text-gray-500 mr-1">pt</span>
        <div class="flex flex-col border-l border-gray-300 pl-1">
            <button onmousedown="event.preventDefault()" onclick="applyPartialFontSizeStep(1)" class="text-[8px] leading-none hover:text-blue-500 hover:bg-blue-50 w-4 h-3 rounded-sm flex items-center justify-center">▲</button>
            <button onmousedown="event.preventDefault()" onclick="applyPartialFontSizeStep(-1)" class="text-[8px] leading-none hover:text-blue-500 hover:bg-blue-50 w-4 h-3 rounded-sm flex items-center justify-center">▼</button>
        </div>
        <button onmousedown="event.preventDefault()" onclick="applyPartialFontSize()" class="ml-1 text-xs text-gray-600 hover:text-blue-500 px-1"><i class="fas fa-check"></i></button>
    </div>
    <div class="flex items-center border-r pr-3 gap-1">
        <button onmousedown="event.preventDefault()" onclick="openImgModal()" class="flex items-center gap-1 bg-purple-100 hover:bg-purple-200 text-purple-700 px-3 py-1 rounded text-xs font-bold transition">
            <i class="fas fa-image"></i> 画像挿入
        </button>
    </div>
    <div class="flex items-center gap-2 ml-auto">
        <a href="https://gemini.google.com/gem/1aQXlT177ks4j2LLC5ooZCyZV3xKGBIlx?usp=sharing" target="_blank"
           class="text-xs bg-indigo-50 text-indigo-700 border border-indigo-200 px-3 py-1 rounded hover:bg-indigo-100 transition flex items-center shadow-sm">
            <i class="fas fa-external-link-alt mr-2"></i> ルビを付けるGemを開く
        </a>
    </div>
</div>

<!-- メインエリア -->
<div class="flex flex-1 overflow-hidden">
    <div class="w-1/2 flex flex-col border-r border-gray-300 bg-gray-50">
        <div class="p-2 bg-gray-100 border-b text-xs font-bold text-gray-500 flex justify-between">
            <span>HTMLソース入力</span>
        </div>
        <textarea id="html-editor"
            class="flex-1 w-full p-4 resize-none focus:outline-none focus:ring-2 focus:ring-blue-300 text-gray-800 text-sm leading-relaxed font-mono"
            placeholder="<!-- ここにHTMLを貼り付けてください -->&#13;&#10;<ruby>漢字<rt>かんじ</rt></ruby>..."
            oninput="updatePreview()" onselect="onEditorSelect()" onmouseup="onEditorSelect()" onkeyup="onEditorSelect()"></textarea>
    </div>

    <div class="w-1/2 flex flex-col bg-gray-200 overflow-hidden">
        <div class="p-2 bg-gray-200/90 backdrop-blur border-b border-gray-300 flex justify-between items-center text-xs font-bold text-gray-500 shrink-0">
            <div class="flex items-center gap-2">
                <!-- 3つのモードボタンを横並びに -->
                <button id="btn-mode-web" class="mode-btn active" onclick="setPreviewMode('web')">WEBプレビュー</button>
                <button id="btn-mode-ruby" class="mode-btn" onclick="setPreviewMode('ruby')">ルビ編集</button>
                <button id="btn-mode-text" class="mode-btn" onclick="setPreviewMode('text')">テキスト編集</button>
            </div>
            <span id="preview-hint" class="text-gray-400">HTMLをそのまま表示</span>
        </div>
        <div class="flex justify-center p-4 min-h-0 flex-1 overflow-y-auto" id="preview-scroll-inner">
            <div id="preview-container" class="page-hp preview-content" spellcheck="false"></div>
            <iframe id="web-iframe" sandbox="allow-same-origin allow-scripts" style="width:100%;height:100%;border:none;background:white;"></iframe>
        </div>
    </div>
</div>

<!-- 画像挿入モーダル -->
<div id="img-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
    <div class="bg-white rounded-xl p-6 w-[480px] shadow-2xl relative">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg text-gray-700"><i class="fas fa-image mr-2 text-purple-500"></i>画像を挿入</h3>
            <button onclick="closeImgModal()" class="text-gray-400 hover:text-gray-600 text-xl leading-none">&times;</button>
        </div>
        <div class="mb-3">
            <label class="block text-xs text-gray-500 mb-1 font-bold">画像のURL</label>
            <input id="img-url-input" type="text" class="w-full border border-gray-300 rounded p-2 text-sm mb-3 focus:outline-none focus:ring-2 focus:ring-purple-300"
                placeholder="https://example.com/image.png" oninput="previewImgUrl()">
            <div id="url-preview-wrap" class="flex justify-center bg-gray-100 rounded p-2 min-h-[80px] items-center">
                <img id="url-preview-img" class="max-w-full max-h-[120px] object-contain hidden" alt="プレビュー">
                <span id="url-preview-placeholder" class="text-gray-400 text-xs">URLを入力するとプレビューが表示されます</span>
            </div>
        </div>
        <div class="mt-4 border-t pt-4">
            <p class="text-xs font-bold text-gray-500 mb-2">サイズ・配置設定</p>
            <div class="flex gap-2 flex-wrap items-end mb-2">
                <div>
                    <label class="block text-xs text-gray-500 mb-1">幅</label>
                    <div class="flex items-center gap-1">
                        <input id="img-width" type="number" placeholder="例: 200" min="1" class="w-20 border border-gray-300 rounded p-1 text-sm" oninput="onImgSizeInput('width')">
                        <select id="img-width-unit" class="border border-gray-300 rounded p-1 text-xs" onchange="onImgSizeInput('width')">
                            <option value="px">px</option>
                            <option value="%">%</option>
                            <option value="em">em</option>
                        </select>
                    </div>
                </div>
                <div class="flex items-end pb-1">
                    <button id="btn-aspect-lock" onclick="toggleAspectLock()" title="縦横比の固定/解除"
                        class="w-8 h-8 flex items-center justify-center rounded border border-gray-300 bg-gray-50 hover:bg-yellow-50 hover:border-yellow-400 transition text-gray-500 text-sm">
                        <i id="aspect-lock-icon" class="fas fa-lock-open"></i>
                    </button>
                </div>
                <div>
                    <label class="block text-xs text-gray-500 mb-1">高さ</label>
                    <div class="flex items-center gap-1">
                        <input id="img-height" type="number" placeholder="auto" min="1" class="w-20 border border-gray-300 rounded p-1 text-sm" oninput="onImgSizeInput('height')">
                        <select id="img-height-unit" class="border border-gray-300 rounded p-1 text-xs" onchange="onImgSizeInput('height')">
                            <option value="px">px</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="flex gap-3 flex-wrap items-end">
                <div>
                    <label class="block text-xs text-gray-500 mb-1">配置</label>
                    <select id="img-align" class="border border-gray-300 rounded p-1 text-sm">
                        <option value="">なし（インライン）</option>
                        <option value="block-center">中央揃え（ブロック）</option>
                        <option value="block-left">左揃え（ブロック）</option>
                        <option value="block-right">右揃え（ブロック）</option>
                        <option value="float-left">左回り込み</option>
                        <option value="float-right">右回り込み</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs text-gray-500 mb-1">alt属性</label>
                    <input id="img-alt" type="text" placeholder="画像の説明" class="border border-gray-300 rounded p-1 text-sm w-28">
                </div>
            </div>
        </div>
        <div class="flex justify-end gap-2 mt-4">
            <button onclick="closeImgModal()" class="px-4 py-2 text-sm text-gray-500 hover:text-gray-700">キャンセル</button>
            <button onclick="insertImage()" class="px-5 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-bold transition">
                <i class="fas fa-check mr-1"></i> 挿入
            </button>
        </div>
    </div>
</div>

<!-- ルビ編集モーダル -->
<div id="ruby-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 w-96 shadow-xl relative">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg text-gray-700"><i class="fas fa-pen mr-2"></i>ルビ編集</h3>
            <span class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded">Enterで次へ</span>
        </div>
        <div class="flex gap-4 mb-6 items-end">
            <div class="flex-1">
                <label class="block text-xs text-gray-400 mb-1">漢字</label>
                <div id="modal-kanji-display" class="text-2xl font-bold text-center bg-gray-100 p-2 rounded text-gray-800"></div>
            </div>
            <div class="flex-1">
                <label class="block text-xs text-blue-500 font-bold mb-1">ふりがな</label>
                <input type="text" id="modal-ruby" class="w-full text-xl border-b-2 border-blue-500 p-2 focus:outline-none bg-transparent text-center" placeholder="読み" autocomplete="off">
            </div>
        </div>
        <div class="flex justify-between gap-2 mb-4">
            <button onclick="navigateRuby(-1)" class="flex-1 py-1 px-2 text-sm bg-gray-100 hover:bg-gray-200 rounded text-gray-600">
                <i class="fas fa-chevron-left mr-1"></i> 前へ
            </button>
            <button onclick="navigateRuby(1)" class="flex-1 py-1 px-2 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded font-bold">
                保存して次へ (Enter) <i class="fas fa-chevron-right ml-1"></i>
            </button>
        </div>
        <div class="flex justify-end pt-4 border-t gap-3">
            <button onclick="closeRubyModal()" class="text-gray-400 hover:text-gray-600 text-sm">閉じる</button>
            <button id="btn-ruby-remove" onclick="removeRubyTag()" class="text-red-400 hover:text-red-600 text-sm">ルビ解除</button>
        </div>
    </div>
</div>

<script>
const editor = document.getElementById('html-editor');
const preview = document.getElementById('preview-container');
const baseFontSizeInput = document.getElementById('base-font-size');
const selFontSizeInput = document.getElementById('sel-font-size');
const webIframe = document.getElementById('web-iframe');
const previewHint = document.getElementById('preview-hint');

let currentTargetRuby = null, lastRange = null;
let currentMode = 'web';
let editorCursorPos = null, previewInsertRange = null;
let aspectLocked = false, aspectRatio = null, changingFrom = null;
// ルビ追加モード用
let addingRubyForSpan = null;

editor.addEventListener('click', () => { editorCursorPos = editor.selectionStart; previewInsertRange = null; });
editor.addEventListener('keyup', () => { editorCursorPos = editor.selectionStart; previewInsertRange = null; });

preview.addEventListener('mouseup', () => {
    const sel = window.getSelection();
    if (sel && sel.rangeCount > 0 && preview.contains(sel.anchorNode)) {
        previewInsertRange = sel.getRangeAt(0).cloneRange();
        previewInsertRange.collapse(true);
        editorCursorPos = null;
    }
});

window.addEventListener('DOMContentLoaded', () => {
    updateBaseFontSize();
    preview.classList.add('hidden');
    webIframe.classList.remove('hidden');
    updateWebIframe();
});

// ===================== エディタ選択 → プレビューハイライト =====================
function onEditorSelect() {
    if (currentMode !== 'ruby') return;
    const start = editor.selectionStart, end = editor.selectionEnd;
    if (start === end) { clearEditorHighlight(); return; }
    const selected = editor.value.substring(start, end);
    if (!selected.trim()) { clearEditorHighlight(); return; }
    highlightInPreview(selected);
}

function clearEditorHighlight() {
    preview.querySelectorAll('.editor-highlight').forEach(el => {
        const parent = el.parentNode;
        while (el.firstChild) parent.insertBefore(el.firstChild, el);
        parent.removeChild(el);
        parent.normalize();
    });
}

function highlightInPreview(text) {
    clearEditorHighlight();
    // テキストノードを走査してマッチ箇所をハイライト
    const plainText = text.replace(/<[^>]+>/g, '');
    if (!plainText.trim()) return;
    // previewのテキスト全体から位置を検索
    const walker = document.createTreeWalker(preview, NodeFilter.SHOW_TEXT);
    const nodes = [];
    let node;
    while ((node = walker.nextNode())) nodes.push(node);

    // 連結してから検索
    const allText = nodes.map(n => n.textContent).join('');
    const idx = allText.indexOf(plainText);
    if (idx < 0) return;

    let pos = 0, startNode = null, endNode = null, startOff = 0, endOff = 0;
    for (const n of nodes) {
        const len = n.textContent.length;
        if (startNode === null && pos + len > idx) {
            startNode = n; startOff = idx - pos;
        }
        if (startNode !== null && endNode === null && pos + len >= idx + plainText.length) {
            endNode = n; endOff = idx + plainText.length - pos;
        }
        pos += len;
        if (startNode && endNode) break;
    }
    if (!startNode || !endNode) return;
    try {
        const range = document.createRange();
        range.setStart(startNode, startOff);
        range.setEnd(endNode, endOff);
        const span = document.createElement('span');
        span.className = 'editor-highlight';
        range.surroundContents(span);
        span.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    } catch(e) { /* cross-node wrap failed */ }
}

// ===================== 縦横比ロック =====================
function toggleAspectLock() {
    aspectLocked = !aspectLocked;
    const icon = document.getElementById('aspect-lock-icon');
    const btn = document.getElementById('btn-aspect-lock');
    if (aspectLocked) {
        icon.className = 'fas fa-lock';
        btn.classList.add('bg-yellow-100','border-yellow-400','text-yellow-600');
        btn.classList.remove('bg-gray-50','border-gray-300','text-gray-500');
        const w = parseFloat(document.getElementById('img-width').value);
        const h = parseFloat(document.getElementById('img-height').value);
        if (w > 0 && h > 0) aspectRatio = w / h;
        else aspectRatio = null;
    } else {
        icon.className = 'fas fa-lock-open';
        btn.classList.remove('bg-yellow-100','border-yellow-400','text-yellow-600');
        btn.classList.add('bg-gray-50','border-gray-300','text-gray-500');
        aspectRatio = null;
    }
}

function onImgSizeInput(from) {
    if (!aspectLocked || changingFrom) return;
    if (aspectRatio === null) {
        const w = parseFloat(document.getElementById('img-width').value);
        const h = parseFloat(document.getElementById('img-height').value);
        if (w > 0 && h > 0) aspectRatio = w / h;
        return;
    }
    changingFrom = from;
    if (from === 'width') {
        const w = parseFloat(document.getElementById('img-width').value);
        if (w > 0 && aspectRatio > 0) document.getElementById('img-height').value = Math.round(w / aspectRatio);
    } else {
        const h = parseFloat(document.getElementById('img-height').value);
        if (h > 0 && aspectRatio > 0) document.getElementById('img-width').value = Math.round(h * aspectRatio);
    }
    changingFrom = null;
}

// ===================== 画像挿入モーダル =====================
function openImgModal() {
    if (!previewInsertRange) editorCursorPos = editor.selectionStart;
    document.getElementById('img-modal').classList.remove('hidden');
    document.getElementById('img-modal').classList.add('flex');
    document.getElementById('img-url-input').value = '';
    document.getElementById('url-preview-img').classList.add('hidden');
    document.getElementById('url-preview-placeholder').textContent = 'URLを入力するとプレビューが表示されます';
    document.getElementById('url-preview-placeholder').classList.remove('hidden');
    document.getElementById('img-width').value = '';
    document.getElementById('img-height').value = '';
    document.getElementById('img-align').value = '';
    document.getElementById('img-alt').value = '';
    aspectLocked = false; aspectRatio = null;
    document.getElementById('aspect-lock-icon').className = 'fas fa-lock-open';
    const btn = document.getElementById('btn-aspect-lock');
    btn.classList.remove('bg-yellow-100','border-yellow-400','text-yellow-600');
    btn.classList.add('bg-gray-50','border-gray-300','text-gray-500');
}
function closeImgModal() {
    document.getElementById('img-modal').classList.add('hidden');
    document.getElementById('img-modal').classList.remove('flex');
}
function previewImgUrl() {
    const url = document.getElementById('img-url-input').value.trim();
    const img = document.getElementById('url-preview-img');
    const ph = document.getElementById('url-preview-placeholder');
    if (!url) { img.classList.add('hidden'); ph.textContent = 'URLを入力するとプレビューが表示されます'; ph.classList.remove('hidden'); return; }
    img.onload = () => {
        img.classList.remove('hidden'); ph.classList.add('hidden');
        if (aspectLocked && img.naturalWidth && img.naturalHeight && !aspectRatio)
            aspectRatio = img.naturalWidth / img.naturalHeight;
    };
    img.onerror = () => { img.classList.add('hidden'); ph.textContent = '⚠ 画像を読み込めません'; ph.classList.remove('hidden'); };
    img.src = url;
}
function buildImgTag(src) {
    const w = document.getElementById('img-width').value.trim();
    const wUnit = document.getElementById('img-width-unit').value;
    const h = document.getElementById('img-height').value.trim();
    const hUnit = document.getElementById('img-height-unit').value;
    const align = document.getElementById('img-align').value;
    const alt = document.getElementById('img-alt').value.trim();
    let style = '';
    if (w) style += `width:${w}${wUnit};`;
    if (h) style += `height:${h}${hUnit};`;
    else if (w) style += 'height:auto;';
    if (align === 'float-left') style += 'float:left;margin-right:0.5em;';
    if (align === 'float-right') style += 'float:right;margin-left:0.5em;';
    const styleAttr = style ? ` style="${style}"` : '';
    const imgTag = `<img src="${src}" alt="${alt}"${styleAttr}>`;
    if (align === 'block-center') return `<div style="text-align:center;line-height:1">${imgTag}</div>`;
    if (align === 'block-left')   return `<div style="text-align:left;line-height:1">${imgTag}</div>`;
    if (align === 'block-right')  return `<div style="text-align:right;line-height:1">${imgTag}</div>`;
    return imgTag;
}
function insertImage() {
    const src = document.getElementById('img-url-input').value.trim();
    if (!src) { alert('URLを入力してください'); return; }
    const tag = buildImgTag(src);
    if (previewInsertRange) {
        const tmpDiv = document.createElement('div');
        tmpDiv.innerHTML = tag;
        const frag = document.createDocumentFragment();
        while (tmpDiv.firstChild) frag.appendChild(tmpDiv.firstChild);
        previewInsertRange.insertNode(frag);
        previewInsertRange = null;
        syncPreviewToEditor();
    } else {
        const pos = (editorCursorPos !== null) ? editorCursorPos : editor.value.length;
        editor.value = editor.value.substring(0, pos) + tag + editor.value.substring(pos);
        editorCursorPos = pos + tag.length;
        editor.selectionStart = editor.selectionEnd = editorCursorPos;
        editor.focus();
    }
    closeImgModal();
    updatePreview();
}

// ===================== プレビューモード切替（3つに統一） =====================
function setPreviewMode(mode) {
    currentMode = mode;
    const btnWeb = document.getElementById('btn-mode-web');
    const btnRuby = document.getElementById('btn-mode-ruby');
    const btnText = document.getElementById('btn-mode-text');
    [btnWeb, btnRuby, btnText].forEach(b => b.classList.remove('active'));

    clearEditorHighlight();

    if (mode === 'web') {
        btnWeb.classList.add('active');
        preview.classList.add('hidden'); webIframe.classList.remove('hidden');
        preview.contentEditable = 'false';
        preview.classList.remove('ruby-edit-mode','text-edit-mode');
        previewHint.textContent = 'HTMLをそのまま表示';
        updateWebIframe();
    } else if (mode === 'ruby') {
        btnRuby.classList.add('active');
        preview.classList.remove('hidden'); webIframe.classList.add('hidden');
        preview.contentEditable = 'false';
        preview.classList.add('ruby-edit-mode'); preview.classList.remove('text-edit-mode');
        previewHint.textContent = 'クリックでルビ編集 / 選択してボタンで装飾';
        preview.removeEventListener('input', onPreviewDirectEdit);
        updatePreview();
        attachRubyClickEvents();
    } else if (mode === 'text') {
        btnText.classList.add('active');
        preview.classList.remove('hidden'); webIframe.classList.add('hidden');
        // テキスト編集前にエディタ→プレビューを同期
        preview.innerHTML = smartBrConvert(editor.value);
        preview.contentEditable = 'true';
        preview.classList.remove('ruby-edit-mode'); preview.classList.add('text-edit-mode');
        previewHint.textContent = 'テキストを直接編集できます';
        preview.querySelectorAll('ruby').forEach(r => { r.onclick = null; });
        preview.addEventListener('input', onPreviewDirectEdit);
    }
}

function onPreviewDirectEdit() { syncPreviewToEditorRaw(); }

function updateWebIframe() {
    const size = parseInt(baseFontSizeInput.value) || 12;
    webIframe.srcdoc = `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><style>
body{font-family:"BIZ UDPGothic","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;font-size:${size}pt;line-height:2.0;padding:1.5rem;margin:0;overflow-wrap:break-word;}
table{border-collapse:collapse;margin:0.5em 0;}th,td{border:1px solid #999;padding:4px 8px;}th{background:#f3f4f6;font-weight:bold;}
ruby{display:inline-ruby;}rt{font-size:0.5em;line-height:1;color:#555;}
img{max-width:100%;display:inline-block;vertical-align:middle;}
</style></head><body>${editor.value}</body></html>`;
}

function openInNewTab() {
    const size = parseInt(baseFontSizeInput.value) || 12;
    const fullHtml = `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>ルビふりお2</title><style>
body{font-family:"BIZ UDPGothic","BIZ UDGothic","Hiragino Kaku Gothic ProN","Hiragino Sans","Meiryo","Yu Gothic",sans-serif;font-size:${size}pt;line-height:2.0;padding:2rem;margin:0;overflow-wrap:break-word;background:white;}
table{border-collapse:collapse;margin:0.5em 0;}th,td{border:1px solid #999;padding:4px 8px;}th{background:#f3f4f6;font-weight:bold;}
ruby{display:inline-ruby;}rt{font-size:0.5em;line-height:1;color:#555;text-align:center;}
img{max-width:100%;display:inline-block;vertical-align:middle;}
</style></head><body>${editor.value}</body></html>`;
    const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
    setTimeout(() => URL.revokeObjectURL(url), 10000);
}

// ===================== 選択範囲の記憶 =====================
function capturePreviewSelectionRange() {
    if (currentMode !== 'ruby') return;
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return;
    const r = sel.getRangeAt(0);
    if (!r.collapsed && preview.contains(r.commonAncestorContainer)) lastRange = r.cloneRange();
}
document.addEventListener('selectionchange', capturePreviewSelectionRange);
['pointerdown','mousedown','touchstart'].forEach(evt => {
    selFontSizeInput.addEventListener(evt, capturePreviewSelectionRange, { passive: true });
});

// ===================== プレビュー更新 =====================
function updatePreview() {
    if (currentMode === 'web') { updateWebIframe(); return; }
    if (currentMode === 'text') return;
    preview.innerHTML = smartBrConvert(editor.value);
    attachRubyClickEvents();
    markKanjiWithoutRuby();
}

function smartBrConvert(html) {
    const PRESERVE = ['table','pre','ol','ul','dl','style','script'];
    const pat = new RegExp(`(<(?:${PRESERVE.join('|')})[^>]*>[\\s\\S]*?</(?:${PRESERVE.join('|')})>)`, 'gi');
    const blocks = [];
    let p = html.replace(pat, m => { blocks.push(m); return `\x00B${blocks.length-1}\x00`; });
    p = p.replace(/\n/g, '<br>');
    return p.replace(/\x00B(\d+)\x00/g, (_, i) => blocks[+i]);
}

function updateBaseFontSize() {
    preview.style.fontSize = (parseInt(baseFontSizeInput.value) || 12) + 'pt';
    if (currentMode === 'web') updateWebIframe();
}
function stepFontSize(d) { baseFontSizeInput.value = Math.max(6, (parseInt(baseFontSizeInput.value)||12)+d); updateBaseFontSize(); }

// ===================== 漢字なのにルビなし → ハイライト & クリックで追加 =====================
const KANJI_RE = /[\u4E00-\u9FFF\u3400-\u4DBF\u20000-\u2A6DF\uF900-\uFAFF]/;

function markKanjiWithoutRuby() {
    if (currentMode !== 'ruby') return;
    // テキストノードを走査して漢字だけのテキストをspanで囲む（rubyの外側のみ）
    const walker = document.createTreeWalker(preview, NodeFilter.SHOW_TEXT, {
        acceptNode(node) {
            // ruby / rt の内側はスキップ
            let p = node.parentElement;
            while (p && p !== preview) {
                if (p.tagName === 'RUBY' || p.tagName === 'RT') return NodeFilter.FILTER_REJECT;
                p = p.parentElement;
            }
            // .kanji-no-ruby のspanはスキップ
            if (node.parentElement && node.parentElement.classList.contains('kanji-no-ruby')) return NodeFilter.FILTER_REJECT;
            return NodeFilter.FILTER_ACCEPT;
        }
    });
    const textNodes = [];
    let n;
    while ((n = walker.nextNode())) textNodes.push(n);

    for (const tn of textNodes) {
        const txt = tn.textContent;
        if (!KANJI_RE.test(txt)) continue;
        // 漢字連続グループごとにspanに分割
        const frag = document.createDocumentFragment();
        let i = 0, chunk = '', inKanji = false;
        const flush = (isKanji) => {
            if (!chunk) return;
            if (isKanji) {
                const sp = document.createElement('span');
                sp.className = 'kanji-no-ruby';
                sp.title = 'クリックしてルビを追加';
                sp.textContent = chunk;
                sp.addEventListener('click', (e) => { e.stopPropagation(); openRubyAddModal(sp); });
                frag.appendChild(sp);
            } else {
                frag.appendChild(document.createTextNode(chunk));
            }
            chunk = '';
        };
        for (const ch of txt) {
            const isK = KANJI_RE.test(ch);
            if (isK !== inKanji) { flush(inKanji); inKanji = isK; }
            chunk += ch;
        }
        flush(inKanji);
        tn.parentNode.replaceChild(frag, tn);
    }
}

// ルビ追加モーダル（既存モーダルを流用）
function openRubyAddModal(spanEl) {
    addingRubyForSpan = spanEl;
    currentTargetRuby = null;
    const modal = document.getElementById('ruby-modal');
    document.getElementById('modal-kanji-display').textContent = spanEl.textContent;
    document.getElementById('modal-ruby').value = '';
    document.getElementById('btn-ruby-remove').style.display = 'none'; // 新規追加時は解除ボタン非表示
    modal.classList.remove('hidden'); modal.classList.add('flex');
    document.getElementById('modal-ruby').focus();
}

function saveNewRuby() {
    if (!addingRubyForSpan) return;
    const reading = document.getElementById('modal-ruby').value.trim();
    if (!reading) { addingRubyForSpan = null; return; }
    const kanji = addingRubyForSpan.textContent;
    const rubyEl = document.createElement('ruby');
    rubyEl.appendChild(document.createTextNode(kanji));
    const rt = document.createElement('rt');
    rt.textContent = reading;
    rubyEl.appendChild(rt);
    addingRubyForSpan.parentNode.replaceChild(rubyEl, addingRubyForSpan);
    addingRubyForSpan = null;
    syncPreviewToEditor();
    attachRubyClickEvents();
    markKanjiWithoutRuby();
}

// ===================== 装飾 =====================
function applyStyleToSelection(s, e2) {
    const sel = window.getSelection();
    if (sel.rangeCount > 0 && preview.contains(sel.anchorNode)) applyStyleToPreview(s, e2, sel.getRangeAt(0));
    else if (lastRange && preview.contains(lastRange.commonAncestorContainer)) applyStyleToPreview(s, e2, lastRange);
    else insertTagToEditor(s, e2);
}
function applyStyleToPreview(s, e2, range) {
    if (!range || range.collapsed) return;
    const tmp = document.createElement('div');
    tmp.innerHTML = s + 'dummy' + e2;
    const wrapper = tmp.firstElementChild;
    if (wrapper) {
        try {
            const lr = range.cloneRange();
            const content = lr.extractContents();
            wrapper.innerHTML = ''; wrapper.appendChild(content);
            lr.insertNode(wrapper);
            syncPreviewToEditor();
            const nr = document.createRange(); nr.selectNodeContents(wrapper);
            const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(nr);
            lastRange = nr.cloneRange();
        } catch(err) { alert('その選択範囲には適用できませんでした'); }
    }
}
function insertTagToEditor(s, e2) {
    const start = editor.selectionStart, end = editor.selectionEnd, txt = editor.value;
    editor.value = txt.substring(0,start) + s + txt.substring(start,end) + e2 + txt.substring(end);
    editor.focus(); editor.selectionStart = start+s.length; editor.selectionEnd = end+s.length;
    updatePreview();
}
function wrapSelection(tag) { applyStyleToSelection(`<${tag}>`, `</${tag}>`); }
function wrapColor(c) { applyStyleToSelection(`<span style="color:${c}">`, '</span>'); }
function wrapFontFamily(f) { if (!f) return; applyStyleToSelection(`<span style="font-family:${f}">`, '</span>'); }
function applyPartialFontSize() {
    const s = parseInt(selFontSizeInput.value); if (!s || s < 6) return;
    applyStyleToSelection(`<span style="font-size:${s}pt">`, '</span>');
}
function applyPartialFontSizeStep(d) {
    capturePreviewSelectionRange();
    selFontSizeInput.value = Math.max(6, (parseInt(selFontSizeInput.value)||16)+d);
    applyPartialFontSize();
}

// ===================== ルビ機能 =====================
function attachRubyClickEvents() {
    preview.querySelectorAll('ruby').forEach(r => {
        r.onclick = (e) => { e.stopPropagation(); openRubyModal(r); };
        r.title = 'ルビを編集';
    });
}

const modal = document.getElementById('ruby-modal');
const modalKanjiDisplay = document.getElementById('modal-kanji-display');
const modalRuby = document.getElementById('modal-ruby');

function openRubyModal(rubyEl) {
    if (currentMode !== 'ruby') return;
    addingRubyForSpan = null;
    if (currentTargetRuby) currentTargetRuby.classList.remove('editing-active');
    currentTargetRuby = rubyEl;
    currentTargetRuby.classList.add('editing-active');
    let kanji = '';
    rubyEl.childNodes.forEach(n => { if (n.nodeType === Node.TEXT_NODE) kanji += n.textContent; });
    const rt = rubyEl.querySelector('rt');
    modalKanjiDisplay.textContent = kanji;
    modalRuby.value = rt ? rt.textContent : '';
    document.getElementById('btn-ruby-remove').style.display = '';
    modal.classList.remove('hidden'); modal.classList.add('flex');
    modalRuby.focus();
}

function closeRubyModal() {
    modal.classList.add('hidden'); modal.classList.remove('flex');
    if (currentTargetRuby) { currentTargetRuby.classList.remove('editing-active'); currentTargetRuby = null; }
    addingRubyForSpan = null;
}

function saveRubyAndStay() {
    if (addingRubyForSpan) { saveNewRuby(); closeRubyModal(); return; }
    if (!currentTargetRuby) return;
    const rt = currentTargetRuby.querySelector('rt');
    if (rt) rt.textContent = modalRuby.value;
    syncPreviewToEditor();
}

function navigateRuby(dir) {
    if (addingRubyForSpan) { saveNewRuby(); closeRubyModal(); return; }
    if (!currentTargetRuby) return;
    saveRubyAndStay();
    const all = Array.from(preview.querySelectorAll('ruby'));
    const ni = all.indexOf(currentTargetRuby) + dir;
    if (ni >= 0 && ni < all.length) openRubyModal(all[ni]);
    else closeRubyModal();
}

function removeRubyTag() {
    if (!currentTargetRuby) return;
    let kanji = '';
    currentTargetRuby.childNodes.forEach(n => { if (n.nodeType === Node.TEXT_NODE) kanji += n.textContent; });
    currentTargetRuby.parentNode.replaceChild(document.createTextNode(kanji), currentTargetRuby);
    syncPreviewToEditor();
    markKanjiWithoutRuby();
    closeRubyModal();
}

// ===================== 同期 =====================
function syncPreviewToEditor() {
    const clone = preview.cloneNode(true);
    // .kanji-no-ruby span と .editor-highlight span を除去してテキストに戻す
    clone.querySelectorAll('.kanji-no-ruby, .editor-highlight').forEach(sp => {
        sp.replaceWith(document.createTextNode(sp.textContent));
    });
    clone.querySelectorAll('table br').forEach(br => br.replaceWith(document.createTextNode('\x00TDBR\x00')));
    clone.querySelectorAll('br').forEach(br => br.replaceWith(document.createTextNode('\n')));
    editor.value = clone.innerHTML.replace(/\x00TDBR\x00/g, '<br>');
}

function syncPreviewToEditorRaw() {
    const clone = preview.cloneNode(true);
    clone.querySelectorAll('.kanji-no-ruby, .editor-highlight').forEach(sp => {
        sp.replaceWith(document.createTextNode(sp.textContent));
    });
    clone.querySelectorAll('table br').forEach(br => br.replaceWith(document.createTextNode('\x00TDBR\x00')));
    clone.querySelectorAll('br').forEach(br => br.replaceWith(document.createTextNode('\n')));
    clone.querySelectorAll('div').forEach(div => { div.insertAdjacentText('afterbegin','\n'); div.replaceWith(...div.childNodes); });
    editor.value = clone.innerHTML.replace(/\x00TDBR\x00/g, '<br>');
}

function copyHtml() { navigator.clipboard.writeText(editor.value).then(() => alert('コピーしました')); }

modal.addEventListener('click', (e) => { if (e.target === modal) closeRubyModal(); });
document.getElementById('img-modal').addEventListener('click', (e) => { if (e.target === document.getElementById('img-modal')) closeImgModal(); });

modalRuby.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        if (addingRubyForSpan) { saveNewRuby(); closeRubyModal(); }
        else navigateRuby(1);
    }
});
selFontSizeInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); capturePreviewSelectionRange(); applyPartialFontSize(); }
});
</script>
</body>
</html>
