<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ルビふりお2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* タイトルの幅がレイアウトに影響しないよう固定 */
        header { min-width: 0; }
        header h1 { white-space: nowrap; flex-shrink: 0; }

        .preview-content {
            font-family: "BIZ UDPGothic","BIZ UDGothic","Hiragino Kaku Gothic ProN","Hiragino Sans","Meiryo","Yu Gothic",sans-serif;
            line-height: 2.0; overflow-wrap: break-word; font-size: 12pt;
        }
        .page-hp { width: 100%; padding: 2rem; background: white; min-height: 100%; box-sizing: border-box; }

        /* ルビ編集モード */
        .ruby-edit-mode ruby { display: inline-ruby; position: relative; cursor: pointer; border-radius: 4px; background-color: transparent; border-bottom: 1px dotted #ccc; }
        .ruby-edit-mode ruby:hover { background-color: #e0f2fe; }
        .ruby-edit-mode ruby.editing-active { background-color: #fce7f3; outline: 2px solid #ec4899; z-index: 10; }

        /* テキスト編集モード */
        .text-edit-mode { cursor: text; outline: none; }
        .text-edit-mode:focus { outline: none; }
        .text-edit-mode ruby { cursor: text !important; border-bottom: none !important; }
        .text-edit-mode ruby:hover { background-color: transparent !important; }

        rt { display: ruby-text; font-size: 0.5em; line-height: 1; text-align: center; color: #555; user-select: none; }
        #preview-container table { border-collapse: collapse; margin: 0.5em 0; }
        #preview-container th, #preview-container td { border: 1px solid #999; padding: 4px 8px; }
        #preview-container th { background: #f3f4f6; font-weight: bold; }
        #web-iframe { width: 100%; height: 100%; border: none; background: white; }

        /* 3択モードボタン（WEBプレビューのデザインで統一） */
        .mode-btn { padding: 4px 14px; border-radius: 9999px; font-size: 0.75rem; font-weight: bold; cursor: pointer; transition: all 0.15s; }
        .mode-btn.active { background: #3b82f6; color: white; }
        .mode-btn:not(.active) { background: #e5e7eb; color: #374151; }
        .mode-btn:not(.active):hover { background: #d1d5db; }

        /* ハイライト */
        .preview-highlight { background: #fef08a; border-radius: 2px; }
        #html-editor { field-sizing: content; }

        /* ルビなしクリック可能テキスト */
        .ruby-edit-mode .ruby-add-target { cursor: pointer; border-bottom: 1px dashed #f59e0b; background: transparent; border-radius: 2px; }
        .ruby-edit-mode .ruby-add-target:hover { background: #fef9c3; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

<!-- ヘッダー -->
<header class="bg-white shadow-sm z-10 p-3 flex justify-between items-center shrink-0 gap-4">
    <h1 class="text-xl font-bold text-gray-700 shrink-0">ルビふりお2</h1>
    <div class="flex gap-2 shrink-0">
        <button onclick="openInNewTab()" class="bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-1.5 rounded text-sm transition whitespace-nowrap">WEBサイトで表示</button>
        <button onclick="copyHtml()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-1.5 rounded text-sm transition whitespace-nowrap"><i class="fas fa-code mr-1"></i>HTMLコピー</button>
    </div>
</header>

<!-- ツールバー -->
<div class="bg-white border-b border-gray-200 p-2 flex flex-wrap gap-3 items-center shrink-0 text-sm">
    <div class="flex items-center border-r pr-3 gap-2">
        <span class="text-gray-500 text-xs font-bold uppercase">全体サイズ</span>
        <div class="flex items-center">
            <input type="number" id="base-font-size" value="12" min="6" max="72" class="w-14 border border-gray-300 rounded p-1 text-center" onchange="updateBaseFontSize()">
            <span class="ml-1 text-gray-600 text-xs">pt</span>
            <div class="flex flex-col ml-1 gap-0.5">
                <button onmousedown="event.preventDefault()" onclick="stepFontSize(1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▲</button>
                <button onmousedown="event.preventDefault()" onclick="stepFontSize(-1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▼</button>
            </div>
        </div>
    </div>
    <div class="flex items-center border-r pr-3 gap-1">
        <select id="font-family-select" onchange="wrapFontFamily(this.value); this.value='';" class="border border-gray-300 rounded p-1 w-24 mr-1 text-xs">
            <option value="" disabled selected>フォント</option>
            <option value="">デフォルト(UD)</option>
            <option value="'UD Digi Kyokasho','YuKyokasho','Kaisho',serif">教科書体</option>
            <option value="'HiraMinProN-W3','YuMincho','MS PMincho',serif">明朝体</option>
            <option value="'Hiragino Kaku Gothic ProN','YuGothic','MS PGothic',sans-serif">ゴシック</option>
            <option value="'Hiragino Maru Gothic ProN','HGMaruGothicMPRO','Rounded Mplus 1c',sans-serif">丸ゴシック</option>
        </select>
        <button onmousedown="event.preventDefault()" onclick="wrapSelection('b')" class="p-1.5 hover:bg-gray-100 rounded" title="太字"><i class="fas fa-bold"></i></button>
        <button onmousedown="event.preventDefault()" onclick="wrapColor('red')" class="p-1.5 hover:bg-gray-100 rounded text-red-500" title="赤文字"><i class="fas fa-font"></i></button>
    </div>
    <div class="flex items-center border border-gray-300 rounded px-1 bg-gray-50">
        <span class="text-[10px] text-gray-500 mr-1 font-bold">選択文字</span>
        <input type="number" id="sel-font-size" value="16" class="w-10 p-0.5 text-center text-xs border-none bg-transparent focus:ring-0 outline-none">
        <span class="text-[10px] text-gray-500 mr-1">pt</span>
        <div class="flex flex-col border-l border-gray-300 pl-1">
            <button onmousedown="event.preventDefault()" onclick="applyPartialFontSizeStep(1)" class="text-[8px] leading-none hover:text-blue-500 hover:bg-blue-50 w-4 h-3 rounded-sm flex items-center justify-center">▲</button>
            <button onmousedown="event.preventDefault()" onclick="applyPartialFontSizeStep(-1)" class="text-[8px] leading-none hover:text-blue-500 hover:bg-blue-50 w-4 h-3 rounded-sm flex items-center justify-center">▼</button>
        </div>
        <button onmousedown="event.preventDefault()" onclick="applyPartialFontSize()" class="ml-1 text-xs text-gray-600 hover:text-blue-500 px-1"><i class="fas fa-check"></i></button>
    </div>
    <div class="flex items-center border-r pr-3 gap-1">
        <button onmousedown="event.preventDefault()" onclick="openImgModal()" class="flex items-center gap-1 bg-purple-100 hover:bg-purple-200 text-purple-700 px-3 py-1 rounded text-xs font-bold transition">
            <i class="fas fa-image"></i> 画像挿入
        </button>
    </div>
    <div class="flex items-center gap-2 ml-auto">
        <a href="https://gemini.google.com/gem/1aQXlT177ks4j2LLC5ooZCyZV3xKGBIlx?usp=sharing" target="_blank"
           class="text-xs bg-indigo-50 text-indigo-700 border border-indigo-200 px-3 py-1 rounded hover:bg-indigo-100 transition flex items-center shadow-sm whitespace-nowrap">
            <i class="fas fa-external-link-alt mr-2"></i>ルビを付けるGemを開く
        </a>
    </div>
</div>

<!-- メインエリア -->
<div class="flex flex-1 overflow-hidden">
    <!-- 左：エディタ -->
    <div class="w-1/2 flex flex-col border-r border-gray-300 bg-gray-50" style="min-width:0">
        <div class="p-2 bg-gray-100 border-b text-xs font-bold text-gray-500">HTMLソース入力</div>
        <textarea id="html-editor"
            class="flex-1 w-full p-4 resize-none focus:outline-none focus:ring-2 focus:ring-blue-300 text-gray-800 text-sm leading-relaxed font-mono"
            placeholder="<!-- ここにHTMLを貼り付けてください -->&#13;&#10;<ruby>漢字<rt>かんじ</rt></ruby>..."
            oninput="updatePreview()" onselect="onEditorSelect()" onmouseup="onEditorSelect()" onkeyup="onEditorSelect()"></textarea>
    </div>

    <!-- 右：プレビュー -->
    <div class="w-1/2 flex flex-col bg-gray-200 overflow-hidden" style="min-width:0">
        <div class="p-2 bg-gray-200/90 backdrop-blur border-b border-gray-300 flex justify-between items-center text-xs font-bold text-gray-500 shrink-0">
            <!-- 3択ボタン -->
            <div class="flex items-center gap-1">
                <button id="btn-mode-web"  class="mode-btn active" onclick="setMode('web')">WEBプレビュー</button>
                <button id="btn-mode-ruby" class="mode-btn"        onclick="setMode('ruby')">ルビ編集</button>
                <button id="btn-mode-text" class="mode-btn"        onclick="setMode('text')">テキスト編集</button>
            </div>
            <span id="preview-hint" class="text-gray-400 ml-2">HTMLをそのまま表示</span>
        </div>
        <div class="flex justify-center p-4 min-h-0 flex-1 overflow-y-auto">
            <div id="preview-container" class="page-hp preview-content" spellcheck="false"></div>
            <iframe id="web-iframe" sandbox="allow-same-origin allow-scripts" style="width:100%;height:100%;border:none;background:white;display:block;"></iframe>
        </div>
    </div>
</div>

<!-- ========== 画像挿入モーダル ========== -->
<div id="img-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
    <div class="bg-white rounded-xl p-6 w-[480px] shadow-2xl relative">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg text-gray-700"><i class="fas fa-image mr-2 text-purple-500"></i>画像を挿入</h3>
            <button onclick="closeImgModal()" class="text-gray-400 hover:text-gray-600 text-xl leading-none">&times;</button>
        </div>
        <div class="mb-3">
            <label class="block text-xs text-gray-500 mb-1 font-bold">画像のURL</label>
            <input id="img-url-input" type="text" class="w-full border border-gray-300 rounded p-2 text-sm mb-3 focus:outline-none focus:ring-2 focus:ring-purple-300"
                placeholder="https://example.com/image.png" oninput="previewImgUrl()">
            <div id="url-preview-wrap" class="flex justify-center bg-gray-100 rounded p-2 min-h-[80px] items-center">
                <img id="url-preview-img" class="max-w-full max-h-[120px] object-contain hidden" alt="プレビュー">
                <span id="url-preview-placeholder" class="text-gray-400 text-xs">URLを入力するとプレビューが表示されます</span>
            </div>
        </div>
        <div class="mt-4 border-t pt-4">
            <p class="text-xs font-bold text-gray-500 mb-2">サイズ・配置設定</p>
            <div class="flex gap-2 flex-wrap items-end mb-2">
                <div>
                    <label class="block text-xs text-gray-500 mb-1">幅</label>
                    <div class="flex items-center gap-1">
                        <input id="img-width" type="number" placeholder="例: 200" min="1" class="w-20 border border-gray-300 rounded p-1 text-sm" oninput="onImgSizeInput('width')">
                        <select id="img-width-unit" class="border border-gray-300 rounded p-1 text-xs" onchange="onImgSizeInput('width')">
                            <option value="px">px</option><option value="%">%</option><option value="em">em</option>
                        </select>
                    </div>
                </div>
                <div class="flex items-end pb-1">
                    <button id="btn-aspect-lock" onclick="toggleAspectLock()" title="縦横比の固定/解除"
                        class="w-8 h-8 flex items-center justify-center rounded border border-gray-300 bg-gray-50 hover:bg-yellow-50 hover:border-yellow-400 transition text-gray-500 text-sm">
                        <i id="aspect-lock-icon" class="fas fa-lock-open"></i>
                    </button>
                </div>
                <div>
                    <label class="block text-xs text-gray-500 mb-1">高さ</label>
                    <div class="flex items-center gap-1">
                        <input id="img-height" type="number" placeholder="auto" min="1" class="w-20 border border-gray-300 rounded p-1 text-sm" oninput="onImgSizeInput('height')">
                        <select id="img-height-unit" class="border border-gray-300 rounded p-1 text-xs">
                            <option value="px">px</option><option value="%">%</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="flex gap-3 flex-wrap items-end">
                <div>
                    <label class="block text-xs text-gray-500 mb-1">配置</label>
                    <select id="img-align" class="border border-gray-300 rounded p-1 text-sm">
                        <option value="">なし（インライン）</option>
                        <option value="block-center">中央揃え（ブロック）</option>
                        <option value="block-left">左揃え（ブロック）</option>
                        <option value="block-right">右揃え（ブロック）</option>
                        <option value="float-left">左回り込み</option>
                        <option value="float-right">右回り込み</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs text-gray-500 mb-1">alt属性</label>
                    <input id="img-alt" type="text" placeholder="画像の説明" class="border border-gray-300 rounded p-1 text-sm w-28">
                </div>
            </div>
        </div>
        <div class="flex justify-end gap-2 mt-4">
            <button onclick="closeImgModal()" class="px-4 py-2 text-sm text-gray-500 hover:text-gray-700">キャンセル</button>
            <button onclick="insertImage()" class="px-5 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-bold transition">
                <i class="fas fa-check mr-1"></i> 挿入
            </button>
        </div>
    </div>
</div>

<!-- ルビ編集モーダル（追加・修正共用） -->
<div id="ruby-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 w-96 shadow-xl relative">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg text-gray-700"><i class="fas fa-pen mr-2"></i><span id="modal-title">ルビ編集</span></h3>
            <span id="modal-enter-hint" class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded">Enterで次へ</span>
        </div>
        <div class="flex gap-4 mb-6 items-end">
            <div class="flex-1">
                <label class="block text-xs text-gray-400 mb-1">テキスト</label>
                <div id="modal-kanji-display" class="text-2xl font-bold text-center bg-gray-100 p-2 rounded text-gray-800 break-all"></div>
            </div>
            <div class="flex-1">
                <label class="block text-xs text-blue-500 font-bold mb-1">ふりがな</label>
                <input type="text" id="modal-ruby" class="w-full text-xl border-b-2 border-blue-500 p-2 focus:outline-none bg-transparent text-center" placeholder="読み" autocomplete="off">
            </div>
        </div>
        <div id="modal-nav-btns" class="flex justify-between gap-2 mb-4">
            <button onclick="navigateRuby(-1)" class="flex-1 py-1 px-2 text-sm bg-gray-100 hover:bg-gray-200 rounded text-gray-600">
                <i class="fas fa-chevron-left mr-1"></i> 前へ
            </button>
            <button onclick="navigateRuby(1)" class="flex-1 py-1 px-2 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded font-bold">
                保存して次へ (Enter) <i class="fas fa-chevron-right ml-1"></i>
            </button>
        </div>
        <div class="flex justify-between pt-4 border-t gap-3">
            <div id="modal-add-btn-wrap" class="hidden">
                <button onclick="confirmAddRuby()" class="px-4 py-1.5 bg-blue-500 hover:bg-blue-600 text-white rounded text-sm font-bold">
                    <i class="fas fa-plus mr-1"></i>ふりがなを追加
                </button>
            </div>
            <div class="flex gap-3 ml-auto">
                <button onclick="closeRubyModal()" class="text-gray-400 hover:text-gray-600 text-sm">閉じる</button>
                <button id="modal-remove-btn" onclick="removeRubyTag()" class="text-red-400 hover:text-red-600 text-sm">ルビ解除</button>
            </div>
        </div>
    </div>
</div>

<script>
const editor = document.getElementById('html-editor');
const preview = document.getElementById('preview-container');
const baseFontSizeInput = document.getElementById('base-font-size');
const selFontSizeInput = document.getElementById('sel-font-size');
const webIframe = document.getElementById('web-iframe');
const previewHint = document.getElementById('preview-hint');

let currentTargetRuby = null, lastRange = null;
let currentMode = 'web'; // 'web' | 'ruby' | 'text'
let addRubyNode = null, addRubyText = null; // ふりがな追加用
let editorCursorPos = null, previewInsertRange = null;
let aspectLocked = false, aspectRatio = null, changingFrom = null;

// ===== 初期化 =====
window.addEventListener('DOMContentLoaded', () => {
    updateBaseFontSize();
    preview.classList.add('hidden');
    updateWebIframe();
});

editor.addEventListener('click', () => { editorCursorPos = editor.selectionStart; previewInsertRange = null; });
editor.addEventListener('keyup', () => { editorCursorPos = editor.selectionStart; previewInsertRange = null; });

preview.addEventListener('mouseup', () => {
    const sel = window.getSelection();
    if (sel && sel.rangeCount > 0 && preview.contains(sel.anchorNode)) {
        previewInsertRange = sel.getRangeAt(0).cloneRange();
        previewInsertRange.collapse(true);
        editorCursorPos = null;
        onPreviewSelect();
    }
});

// ===== モード切替（3択） =====
function setMode(mode) {
    // テキスト編集→他モードへ切替時は同期
    if (currentMode === 'text' && mode !== 'text') {
        syncPreviewToEditorRaw();
        preview.contentEditable = 'false';
        preview.removeEventListener('input', onPreviewDirectEdit);
        preview.classList.remove('text-edit-mode');
    }
    currentMode = mode;
    ['web','ruby','text'].forEach(m => {
        document.getElementById('btn-mode-' + m).classList.toggle('active', m === mode);
    });

    if (mode === 'web') {
        preview.classList.add('hidden'); webIframe.style.display = 'block';
        preview.classList.remove('ruby-edit-mode');
        previewHint.textContent = 'HTMLをそのまま表示';
        updateWebIframe();
    } else if (mode === 'ruby') {
        webIframe.style.display = 'none'; preview.classList.remove('hidden');
        preview.contentEditable = 'false';
        preview.classList.add('ruby-edit-mode'); preview.classList.remove('text-edit-mode');
        previewHint.textContent = 'クリックでルビ編集 / 選択でふりがな追加';
        updatePreviewInner();
    } else { // text
        webIframe.style.display = 'none'; preview.classList.remove('hidden');
        preview.classList.remove('ruby-edit-mode'); preview.classList.add('text-edit-mode');
        preview.contentEditable = 'true';
        previewHint.textContent = 'テキストを直接編集できます';
        preview.querySelectorAll('ruby').forEach(r => { r.onclick = null; });
        preview.addEventListener('input', onPreviewDirectEdit);
        updatePreviewInner();
    }
}

function onPreviewDirectEdit() { syncPreviewToEditorRaw(); }

// ===== プレビュー更新 =====
function updatePreview() {
    if (currentMode === 'web') { updateWebIframe(); return; }
    if (currentMode === 'text') return;
    updatePreviewInner();
}

function updatePreviewInner() {
    preview.innerHTML = smartBrConvert(editor.value);
    if (currentMode === 'ruby') attachRubyEvents();
}

function smartBrConvert(html) {
    const PRESERVE = ['table','pre','ol','ul','dl','style','script'];
    const pat = new RegExp(`(<(?:${PRESERVE.join('|')})[^>]*>[\\s\\S]*?</(?:${PRESERVE.join('|')})>)`, 'gi');
    const blocks = [];
    let p = html.replace(pat, m => { blocks.push(m); return `\x00B${blocks.length-1}\x00`; });
    p = p.replace(/\n/g, '<br>');
    return p.replace(/\x00B(\d+)\x00/g, (_, i) => blocks[+i]);
}

function updateBaseFontSize() {
    preview.style.fontSize = (parseInt(baseFontSizeInput.value) || 12) + 'pt';
    if (currentMode === 'web') updateWebIframe();
}
function stepFontSize(d) { baseFontSizeInput.value = Math.max(6, (parseInt(baseFontSizeInput.value)||12)+d); updateBaseFontSize(); }

function updateWebIframe() {
    const size = parseInt(baseFontSizeInput.value) || 12;
    webIframe.srcdoc = `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><style>
body{font-family:"BIZ UDPGothic","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;font-size:${size}pt;line-height:2.0;padding:1.5rem;margin:0;overflow-wrap:break-word;}
table{border-collapse:collapse;margin:.5em 0;}th,td{border:1px solid #999;padding:4px 8px;}th{background:#f3f4f6;font-weight:bold;}
ruby{display:inline-ruby;}rt{font-size:.5em;line-height:1;color:#555;}
img{max-width:100%;display:inline-block;vertical-align:middle;}
</style></head><body>${editor.value}</body></html>`;
}

function openInNewTab() {
    const size = parseInt(baseFontSizeInput.value) || 12;
    const fullHtml = `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>ルビふりお2</title><style>
body{font-family:"BIZ UDPGothic","BIZ UDGothic","Hiragino Kaku Gothic ProN","Hiragino Sans","Meiryo","Yu Gothic",sans-serif;font-size:${size}pt;line-height:2.0;padding:2rem;margin:0;overflow-wrap:break-word;background:white;}
table{border-collapse:collapse;margin:.5em 0;}th,td{border:1px solid #999;padding:4px 8px;}th{background:#f3f4f6;font-weight:bold;}
ruby{display:inline-ruby;}rt{font-size:.5em;line-height:1;color:#555;text-align:center;}
img{max-width:100%;display:inline-block;vertical-align:middle;}
</style></head><body>${editor.value}</body></html>`;
    const blob = new Blob([fullHtml], {type:'text/html;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
    setTimeout(() => URL.revokeObjectURL(url), 10000);
}

// ===== ルビイベント付与 =====
function attachRubyEvents() {
    // 既存rubyタグ → クリックで編集
    preview.querySelectorAll('ruby').forEach(r => {
        r.onclick = (e) => { e.stopPropagation(); openRubyEditModal(r); };
        r.title = 'ルビを編集';
    });
    // rubyなしテキストノード → クリックで追加
    attachAddTargets();
}

function attachAddTargets() {
    // テキストノードを持つ要素を走査して、選択していなければ全テキストをクリック可能に
    // 実装：プレビュー内のテキストノードをspanでラップしてクリック検知
    walkTextNodes(preview);
}

function walkTextNodes(node) {
    // ruby の中・既にラップ済みは除外
    if (node.nodeName === 'RUBY' || node.nodeName === 'RT' || node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE') return;
    if (node.nodeType === Node.TEXT_NODE) {
        const txt = node.textContent;
        if (!txt.trim()) return;
        // テキストノードをspanでラップ
        const span = document.createElement('span');
        span.className = 'ruby-add-target';
        span.title = 'ふりがなを追加';
        span.textContent = txt;
        span.dataset.originalText = txt;
        span.onclick = (e) => { e.stopPropagation(); openRubyAddModal(span, txt); };
        node.parentNode.replaceChild(span, node);
        return;
    }
    // childNodesをコピーしてから走査（DOM変更に対応）
    Array.from(node.childNodes).forEach(child => walkTextNodes(child));
}

// ===== ハイライト機能 =====
let hlTimeout = null;

function onEditorSelect() {
    clearTimeout(hlTimeout);
    hlTimeout = setTimeout(() => {
        if (currentMode !== 'ruby' && currentMode !== 'text') return;
        const start = editor.selectionStart, end = editor.selectionEnd;
        if (start === end) { clearPreviewHighlight(); return; }
        const sel = editor.value.substring(start, end).trim();
        if (!sel) { clearPreviewHighlight(); return; }
        // HTML除去して純テキスト検索
        const plain = sel.replace(/<[^>]+>/g, '');
        if (plain.length < 1) { clearPreviewHighlight(); return; }
        highlightInPreview(plain);
    }, 200);
}

function highlightInPreview(text) {
    clearPreviewHighlight();
    if (!text) return;
    // プレビュー内のテキストを検索してmarkタグでハイライト
    const escaped = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    highlightTextInNode(preview, new RegExp(escaped, 'g'));
}

function highlightTextInNode(node, re) {
    if (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE' || node.nodeName === 'MARK') return;
    if (node.nodeType === Node.TEXT_NODE) {
        const txt = node.textContent;
        if (!re.test(txt)) return;
        re.lastIndex = 0;
        const frag = document.createDocumentFragment();
        let last = 0, m;
        while ((m = re.exec(txt)) !== null) {
            if (m.index > last) frag.appendChild(document.createTextNode(txt.slice(last, m.index)));
            const mark = document.createElement('mark');
            mark.className = 'preview-highlight';
            mark.textContent = m[0];
            frag.appendChild(mark);
            last = re.lastIndex;
        }
        if (last < txt.length) frag.appendChild(document.createTextNode(txt.slice(last)));
        node.parentNode.replaceChild(frag, node);
        return;
    }
    Array.from(node.childNodes).forEach(c => highlightTextInNode(c, re));
}

function clearPreviewHighlight() {
    preview.querySelectorAll('mark.preview-highlight').forEach(m => {
        const txt = document.createTextNode(m.textContent);
        m.parentNode.replaceChild(txt, m);
    });
    // テキストノード統合
    preview.normalize();
}

// プレビュー選択 → エディタハイライト（背景色でマーク）
let editorHighlightRange = null;

function onPreviewSelect() {
    if (currentMode !== 'ruby' && currentMode !== 'text') return;
    setTimeout(() => {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.isCollapsed) { clearEditorHighlight(); return; }
        const txt = sel.toString().trim();
        if (!txt || txt.length < 1) { clearEditorHighlight(); return; }
        highlightInEditor(txt);
    }, 100);
}

function highlightInEditor(text) {
    clearEditorHighlight();
    const src = editor.value;
    const idx = src.indexOf(text);
    if (idx < 0) {
        // HTML除去後でも試みる（rubyタグ内テキスト等）
        const plain = src.replace(/<[^>]+>/g, '');
        const pi = plain.indexOf(text);
        if (pi < 0) return;
    }
    // textareaは直接ハイライトできないため選択で代用
    const start = src.indexOf(text);
    if (start < 0) return;
    editor.focus();
    editor.setSelectionRange(start, start + text.length);
    // スクロールも合わせる
    const lineH = parseInt(getComputedStyle(editor).lineHeight) || 20;
    const lines = src.substring(0, start).split('\n').length;
    editor.scrollTop = Math.max(0, (lines - 3) * lineH);
}

function clearEditorHighlight() {
    // 選択解除はしない（ユーザー操作を邪魔しないため）
}

// ===== ルビモーダル（既存rubyの編集） =====
const modal = document.getElementById('ruby-modal');
const modalKanjiDisplay = document.getElementById('modal-kanji-display');
const modalRubyInput = document.getElementById('modal-ruby');

function openRubyEditModal(rubyEl) {
    addRubyNode = null; addRubyText = null;
    if (currentTargetRuby) currentTargetRuby.classList.remove('editing-active');
    currentTargetRuby = rubyEl;
    currentTargetRuby.classList.add('editing-active');
    let kanji = '';
    rubyEl.childNodes.forEach(n => { if (n.nodeType === Node.TEXT_NODE) kanji += n.textContent; });
    const rt = rubyEl.querySelector('rt');
    document.getElementById('modal-title').textContent = 'ルビ編集';
    document.getElementById('modal-enter-hint').classList.remove('hidden');
    document.getElementById('modal-nav-btns').classList.remove('hidden');
    document.getElementById('modal-add-btn-wrap').classList.add('hidden');
    document.getElementById('modal-remove-btn').classList.remove('hidden');
    modalKanjiDisplay.textContent = kanji;
    modalRubyInput.value = rt ? rt.textContent : '';
    modal.classList.remove('hidden'); modal.classList.add('flex');
    modalRubyInput.focus();
}

function openRubyAddModal(spanEl, text) {
    addRubyNode = spanEl; addRubyText = text;
    if (currentTargetRuby) currentTargetRuby.classList.remove('editing-active');
    currentTargetRuby = null;
    document.getElementById('modal-title').textContent = 'ふりがなを追加';
    document.getElementById('modal-enter-hint').classList.add('hidden');
    document.getElementById('modal-nav-btns').classList.add('hidden');
    document.getElementById('modal-add-btn-wrap').classList.remove('hidden');
    document.getElementById('modal-remove-btn').classList.add('hidden');
    modalKanjiDisplay.textContent = text;
    modalRubyInput.value = '';
    modal.classList.remove('hidden'); modal.classList.add('flex');
    modalRubyInput.focus();
}

function confirmAddRuby() {
    if (!addRubyNode) return;
    const reading = modalRubyInput.value.trim();
    if (!reading) { closeRubyModal(); return; }
    // spanをrubyタグに置換
    const rubyEl = document.createElement('ruby');
    rubyEl.appendChild(document.createTextNode(addRubyText));
    const rt = document.createElement('rt');
    rt.textContent = reading;
    rubyEl.appendChild(rt);
    addRubyNode.parentNode.replaceChild(rubyEl, addRubyNode);
    syncPreviewToEditor();
    closeRubyModal();
    attachRubyEvents();
}

function closeRubyModal() {
    modal.classList.add('hidden'); modal.classList.remove('flex');
    if (currentTargetRuby) { currentTargetRuby.classList.remove('editing-active'); currentTargetRuby = null; }
    addRubyNode = null; addRubyText = null;
}

function saveRubyAndStay() {
    if (!currentTargetRuby) return;
    const rt = currentTargetRuby.querySelector('rt');
    if (rt) rt.textContent = modalRubyInput.value;
    syncPreviewToEditor();
}

function navigateRuby(dir) {
    if (!currentTargetRuby) return;
    saveRubyAndStay();
    const all = Array.from(preview.querySelectorAll('ruby'));
    const ni = all.indexOf(currentTargetRuby) + dir;
    if (ni >= 0 && ni < all.length) openRubyEditModal(all[ni]);
    else closeRubyModal();
}

function removeRubyTag() {
    if (!currentTargetRuby) return;
    let kanji = '';
    currentTargetRuby.childNodes.forEach(n => { if (n.nodeType === Node.TEXT_NODE) kanji += n.textContent; });
    currentTargetRuby.parentNode.replaceChild(document.createTextNode(kanji), currentTargetRuby);
    syncPreviewToEditor(); closeRubyModal();
}

// ===== 選択範囲記憶 =====
function capturePreviewSelectionRange() {
    if (currentMode === 'text') return;
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return;
    const r = sel.getRangeAt(0);
    if (!r.collapsed && preview.contains(r.commonAncestorContainer)) lastRange = r.cloneRange();
}
document.addEventListener('selectionchange', capturePreviewSelectionRange);
['pointerdown','mousedown','touchstart'].forEach(evt => {
    selFontSizeInput.addEventListener(evt, capturePreviewSelectionRange, {passive:true});
});

// ===== 装飾 =====
function applyStyleToSelection(s, e2) {
    const sel = window.getSelection();
    if (sel.rangeCount > 0 && preview.contains(sel.anchorNode)) applyStyleToPreview(s, e2, sel.getRangeAt(0));
    else if (lastRange && preview.contains(lastRange.commonAncestorContainer)) applyStyleToPreview(s, e2, lastRange);
    else insertTagToEditor(s, e2);
}
function applyStyleToPreview(s, e2, range) {
    if (!range || range.collapsed) return;
    const tmp = document.createElement('div');
    tmp.innerHTML = s + 'dummy' + e2;
    const wrapper = tmp.firstElementChild;
    if (wrapper) {
        try {
            const lr = range.cloneRange();
            const content = lr.extractContents();
            wrapper.innerHTML = ''; wrapper.appendChild(content);
            lr.insertNode(wrapper);
            syncPreviewToEditor();
            const nr = document.createRange(); nr.selectNodeContents(wrapper);
            const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(nr);
            lastRange = nr.cloneRange();
        } catch(err) { alert('その選択範囲には適用できませんでした'); }
    }
}
function insertTagToEditor(s, e2) {
    const start = editor.selectionStart, end = editor.selectionEnd, txt = editor.value;
    editor.value = txt.substring(0,start) + s + txt.substring(start,end) + e2 + txt.substring(end);
    editor.focus(); editor.selectionStart = start+s.length; editor.selectionEnd = end+s.length;
    updatePreview();
}
function wrapSelection(tag) { applyStyleToSelection(`<${tag}>`,`</${tag}>`); }
function wrapColor(c) { applyStyleToSelection(`<span style="color:${c}">`,'</span>'); }
function wrapFontFamily(f) { if(!f) return; applyStyleToSelection(`<span style="font-family:${f}">`,'</span>'); }
function applyPartialFontSize() {
    const s = parseInt(selFontSizeInput.value); if(!s||s<6) return;
    applyStyleToSelection(`<span style="font-size:${s}pt">`,'</span>');
}
function applyPartialFontSizeStep(d) {
    capturePreviewSelectionRange();
    selFontSizeInput.value = Math.max(6,(parseInt(selFontSizeInput.value)||16)+d);
    applyPartialFontSize();
}

// ===== 縦横比ロック =====
function toggleAspectLock() {
    aspectLocked = !aspectLocked;
    const icon = document.getElementById('aspect-lock-icon');
    const btn = document.getElementById('btn-aspect-lock');
    if (aspectLocked) {
        icon.className = 'fas fa-lock';
        btn.classList.add('bg-yellow-100','border-yellow-400','text-yellow-600');
        btn.classList.remove('bg-gray-50','border-gray-300','text-gray-500');
        const w = parseFloat(document.getElementById('img-width').value);
        const h = parseFloat(document.getElementById('img-height').value);
        if (w>0&&h>0) aspectRatio = w/h; else aspectRatio = null;
    } else {
        icon.className = 'fas fa-lock-open';
        btn.classList.remove('bg-yellow-100','border-yellow-400','text-yellow-600');
        btn.classList.add('bg-gray-50','border-gray-300','text-gray-500');
        aspectRatio = null;
    }
}
function onImgSizeInput(from) {
    if (!aspectLocked || changingFrom) return;
    if (aspectRatio === null) {
        const w = parseFloat(document.getElementById('img-width').value);
        const h = parseFloat(document.getElementById('img-height').value);
        if (w>0&&h>0) aspectRatio = w/h;
        return;
    }
    changingFrom = from;
    if (from==='width') {
        const w = parseFloat(document.getElementById('img-width').value);
        if (w>0&&aspectRatio>0) document.getElementById('img-height').value = Math.round(w/aspectRatio);
    } else {
        const h = parseFloat(document.getElementById('img-height').value);
        if (h>0&&aspectRatio>0) document.getElementById('img-width').value = Math.round(h*aspectRatio);
    }
    changingFrom = null;
}

// ===== 画像挿入モーダル =====
function openImgModal() {
    if (!previewInsertRange) editorCursorPos = editor.selectionStart;
    document.getElementById('img-modal').classList.remove('hidden');
    document.getElementById('img-modal').classList.add('flex');
    document.getElementById('img-url-input').value = '';
    document.getElementById('url-preview-img').classList.add('hidden');
    document.getElementById('url-preview-placeholder').textContent = 'URLを入力するとプレビューが表示されます';
    document.getElementById('url-preview-placeholder').classList.remove('hidden');
    document.getElementById('img-width').value = '';
    document.getElementById('img-height').value = '';
    document.getElementById('img-align').value = '';
    document.getElementById('img-alt').value = '';
    aspectLocked = false; aspectRatio = null;
    document.getElementById('aspect-lock-icon').className = 'fas fa-lock-open';
    const btn = document.getElementById('btn-aspect-lock');
    btn.classList.remove('bg-yellow-100','border-yellow-400','text-yellow-600');
    btn.classList.add('bg-gray-50','border-gray-300','text-gray-500');
}
function closeImgModal() {
    document.getElementById('img-modal').classList.add('hidden');
    document.getElementById('img-modal').classList.remove('flex');
}
function previewImgUrl() {
    const url = document.getElementById('img-url-input').value.trim();
    const img = document.getElementById('url-preview-img');
    const ph = document.getElementById('url-preview-placeholder');
    if (!url) { img.classList.add('hidden'); ph.textContent='URLを入力するとプレビューが表示されます'; ph.classList.remove('hidden'); return; }
    img.onload = () => { img.classList.remove('hidden'); ph.classList.add('hidden'); if(aspectLocked&&!aspectRatio&&img.naturalWidth&&img.naturalHeight) aspectRatio=img.naturalWidth/img.naturalHeight; };
    img.onerror = () => { img.classList.add('hidden'); ph.textContent='⚠ 画像を読み込めません'; ph.classList.remove('hidden'); };
    img.src = url;
}
function buildImgTag(src) {
    const w=document.getElementById('img-width').value.trim();
    const wU=document.getElementById('img-width-unit').value;
    const h=document.getElementById('img-height').value.trim();
    const hU=document.getElementById('img-height-unit').value;
    const align=document.getElementById('img-align').value;
    const alt=document.getElementById('img-alt').value.trim();
    let style='';
    if(w) style+=`width:${w}${wU};`;
    if(h) style+=`height:${h}${hU};`;
    else if(w) style+='height:auto;';
    if(align==='float-left') style+='float:left;margin-right:.5em;';
    if(align==='float-right') style+='float:right;margin-left:.5em;';
    const sa=style?` style="${style}"`:'';
    const imgTag=`<img src="${src}" alt="${alt}"${sa}>`;
    if(align==='block-center') return `<div style="text-align:center;line-height:1">${imgTag}</div>`;
    if(align==='block-left') return `<div style="text-align:left;line-height:1">${imgTag}</div>`;
    if(align==='block-right') return `<div style="text-align:right;line-height:1">${imgTag}</div>`;
    return imgTag;
}
function insertImage() {
    const src=document.getElementById('img-url-input').value.trim();
    if(!src){alert('URLを入力してください');return;}
    const tag=buildImgTag(src);
    if (previewInsertRange) {
        const tmpDiv=document.createElement('div'); tmpDiv.innerHTML=tag;
        const frag=document.createDocumentFragment();
        while(tmpDiv.firstChild) frag.appendChild(tmpDiv.firstChild);
        previewInsertRange.insertNode(frag); previewInsertRange=null;
        syncPreviewToEditor();
    } else {
        const pos=(editorCursorPos!==null)?editorCursorPos:editor.value.length;
        editor.value=editor.value.substring(0,pos)+tag+editor.value.substring(pos);
        editorCursorPos=pos+tag.length;
        editor.selectionStart=editor.selectionEnd=editorCursorPos;
        editor.focus();
    }
    closeImgModal(); updatePreview();
}

// ===== 同期 =====
function syncPreviewToEditor() {
    const clone=preview.cloneNode(true);
    // ハイライト用mark・ふりがな追加用spanを除去してテキストに戻す
    clone.querySelectorAll('mark.preview-highlight').forEach(m=>{m.replaceWith(document.createTextNode(m.textContent));});
    clone.querySelectorAll('span.ruby-add-target').forEach(s=>{s.replaceWith(document.createTextNode(s.dataset.originalText||s.textContent));});
    clone.querySelectorAll('table br').forEach(br=>br.replaceWith(document.createTextNode('\x00TDBR\x00')));
    clone.querySelectorAll('br').forEach(br=>br.replaceWith(document.createTextNode('\n')));
    editor.value=clone.innerHTML.replace(/\x00TDBR\x00/g,'<br>');
}
function syncPreviewToEditorRaw() {
    const clone=preview.cloneNode(true);
    clone.querySelectorAll('mark.preview-highlight').forEach(m=>{m.replaceWith(document.createTextNode(m.textContent));});
    clone.querySelectorAll('span.ruby-add-target').forEach(s=>{s.replaceWith(document.createTextNode(s.dataset.originalText||s.textContent));});
    clone.querySelectorAll('table br').forEach(br=>br.replaceWith(document.createTextNode('\x00TDBR\x00')));
    clone.querySelectorAll('br').forEach(br=>br.replaceWith(document.createTextNode('\n')));
    clone.querySelectorAll('div').forEach(div=>{div.insertAdjacentText('afterbegin','\n');div.replaceWith(...div.childNodes);});
    editor.value=clone.innerHTML.replace(/\x00TDBR\x00/g,'<br>');
}

function copyHtml() { navigator.clipboard.writeText(editor.value).then(()=>alert('コピーしました')); }

// ===== イベント =====
modal.addEventListener('click', e=>{ if(e.target===modal) closeRubyModal(); });
document.getElementById('img-modal').addEventListener('click', e=>{ if(e.target===document.getElementById('img-modal')) closeImgModal(); });
modalRubyInput.addEventListener('keydown', e=>{
    if(e.key==='Enter'){
        e.preventDefault();
        if(addRubyNode) confirmAddRuby();
        else navigateRuby(1);
    }
});
selFontSizeInput.addEventListener('keydown', e=>{
    if(e.key==='Enter'){e.preventDefault();capturePreviewSelectionRange();applyPartialFontSize();}
});
</script>
</body>
</html>
