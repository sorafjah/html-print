<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ルビふりお2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @media print {
            body * { visibility: hidden; }
            #preview-container, #preview-container * { visibility: visible; }
            #preview-container {
                position: absolute;
                left: 0; top: 0; width: 100%; margin: 0; padding: 0;
                box-shadow: none; background: white;
            }
            .page-hp {
                box-shadow: none !important; margin: 0 !important;
                width: 100% !important; height: auto !important;
            }
            .page-a4 {
                box-shadow: none !important; margin: 0 !important;
                width: 100% !important; height: auto !important;
            }
            ruby { ruby-position: over; }
        }

        .preview-content {
            font-family: "BIZ UDPGothic", "BIZ UDGothic", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Meiryo", "Yu Gothic", sans-serif;
            line-height: 2.0;
            overflow-wrap: break-word;
            font-size: 12pt;
        }

        .page-hp {
            width: 100%; padding: 2rem; background: white; min-height: 100%;
        }
        .page-a4 {
            width: 210mm; min-height: 297mm; padding: 20mm; margin: 0 auto;
            background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); box-sizing: border-box;
        }

        /* ルビ編集モード用スタイル */
        .ruby-edit-mode ruby {
            display: inline-ruby;
            position: relative;
            cursor: pointer;
            border-radius: 4px;
            background-color: transparent;
            border-bottom: 1px dotted #ccc;
        }
        .ruby-edit-mode ruby:hover { background-color: #e0f2fe; }
        .ruby-edit-mode ruby.editing-active {
            background-color: #fce7f3; outline: 2px solid #ec4899; z-index: 10;
        }
        rt {
            display: ruby-text; font-size: 0.5em; line-height: 1;
            text-align: center; color: #555; user-select: none;
        }

        /* テーブルのデフォルトスタイル（プレビュー内） */
        #preview-container table {
            border-collapse: collapse;
            margin: 0.5em 0;
        }
        #preview-container th,
        #preview-container td {
            border: 1px solid #999;
            padding: 4px 8px;
        }
        #preview-container th {
            background: #f3f4f6;
            font-weight: bold;
        }

        /* iframeモード */
        #web-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
        }

        #html-editor { font-family: monospace; white-space: pre-wrap; }

        /* モード切替ボタン */
        .mode-btn {
            padding: 4px 14px;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
        }
        .mode-btn.active {
            background: #3b82f6;
            color: white;
        }
        .mode-btn:not(.active) {
            background: #e5e7eb;
            color: #374151;
        }
        .mode-btn:not(.active):hover {
            background: #d1d5db;
        }

        /* テキスト編集モード用スタイル */
        .text-edit-mode {
            cursor: text;
            outline: none;
        }
        .text-edit-mode:focus {
            outline: none;
        }
        /* テキスト編集モード時：rubyはクリックで開かず普通のテキストとして振る舞う */
        .text-edit-mode ruby {
            cursor: text !important;
            border-bottom: none !important;
        }
        .text-edit-mode ruby:hover {
            background-color: transparent !important;
        }

        /* 編集モードインジケーター */
        #edit-mode-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 9999px;
            transition: all 0.2s;
        }
        #edit-mode-indicator.mode-ruby {
            background: #dcfce7;
            color: #16a34a;
        }
        #edit-mode-indicator.mode-text {
            background: #fef9c3;
            color: #a16207;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

<!-- ヘッダー -->
<header class="bg-white shadow-sm z-10 p-3 flex justify-between items-center shrink-0">
    <h1 class="text-xl font-bold text-gray-700">ルビふりお2</h1>
    <div class="flex gap-2">
        <button onclick="openInNewTab()" class="bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-1.5 rounded text-sm transition">
            <i class="fas fa-external-link-alt mr-1"></i> 新しいタブで開く
        </button>
        <button onclick="copyHtml()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-1.5 rounded text-sm transition">
            <i class="fas fa-code mr-1"></i> HTMLコピー
        </button>
        <button onclick="window.print()" class="bg-gray-700 hover:bg-gray-800 text-white px-4 py-1.5 rounded text-sm transition">
            <i class="fas fa-print mr-1"></i> 印刷
        </button>
    </div>
</header>

<!-- ツールバー -->
<div class="bg-white border-b border-gray-200 p-2 flex flex-wrap gap-3 items-center shrink-0 text-sm">

    <!-- レイアウト -->
    <div class="flex items-center border-r pr-3 gap-2">
        <span class="text-gray-500 text-xs font-bold uppercase">レイアウト</span>
        <select id="layout-select" onchange="changeLayout()" class="border border-gray-300 rounded p-1">
            <option value="hp">HP用 (Web)</option>
            <option value="a4">A4印刷用</option>
        </select>
    </div>

    <!-- 基本サイズ -->
    <div class="flex items-center border-r pr-3 gap-2">
        <span class="text-gray-500 text-xs font-bold uppercase">全体サイズ</span>
        <div class="flex items-center">
            <input type="number" id="base-font-size" value="12" min="6" max="72" class="w-14 border border-gray-300 rounded p-1 text-center" onchange="updateBaseFontSize()">
            <span class="ml-1 text-gray-600 text-xs">pt</span>
            <div class="flex flex-col ml-1 gap-0.5">
                <button onmousedown="event.preventDefault()" onclick="stepFontSize(1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▲</button>
                <button onmousedown="event.preventDefault()" onclick="stepFontSize(-1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▼</button>
            </div>
        </div>
    </div>

    <!-- 装飾ボタン群 -->
    <div class="flex items-center border-r pr-3 gap-1">
        <select id="font-family-select" onchange="wrapFontFamily(this.value); this.value='';" class="border border-gray-300 rounded p-1 w-24 mr-1 text-xs" title="選択部分のフォント変更">
            <option value="" disabled selected>フォント</option>
            <option value="">デフォルト(UD)</option>
            <option value="'UD Digi Kyokasho', 'YuKyokasho', 'Kaisho', serif">教科書体</option>
            <option value="'HiraMinProN-W3', 'YuMincho', 'MS PMincho', serif">明朝体</option>
            <option value="'Hiragino Kaku Gothic ProN', 'YuGothic', 'MS PGothic', sans-serif">ゴシック</option>
            <option value="'Hiragino Maru Gothic ProN', 'HGMaruGothicMPRO', 'Rounded Mplus 1c', sans-serif">丸ゴシック</option>
        </select>
        <button onmousedown="event.preventDefault()" onclick="wrapSelection('b')" class="p-1.5 hover:bg-gray-100 rounded" title="太字"><i class="fas fa-bold"></i></button>
        <button onmousedown="event.preventDefault()" onclick="wrapColor('red')" class="p-1.5 hover:bg-gray-100 rounded text-red-500" title="赤文字"><i class="fas fa-font"></i></button>
    </div>

    <!-- 選択部分のサイズ変更 -->
    <div class="flex items-center border border-gray-300 rounded px-1 ml-1 bg-gray-50" id="partial-fontsize-box">
        <span class="text-[10px] text-gray-500 mr-1 font-bold">選択文字</span>
        <input type="number" id="sel-font-size" value="16" class="w-10 p-0.5 text-center text-xs border-none bg-transparent focus:ring-0 outline-none" title="サイズを入力してEnter">
        <span class="text-[10px] text-gray-500 mr-1">pt</span>
        <div class="flex flex-col border-l border-gray-300 pl-1">
            <button onmousedown="event.preventDefault()" onclick="applyPartialFontSizeStep(1)" class="text-[8px] leading-none hover:text-blue-500 hover:bg-blue-50 w-4 h-3 rounded-sm flex items-center justify-center">▲</button>
            <button onmousedown="event.preventDefault()" onclick="applyPartialFontSizeStep(-1)" class="text-[8px] leading-none hover:text-blue-500 hover:bg-blue-50 w-4 h-3 rounded-sm flex items-center justify-center">▼</button>
        </div>
        <button onmousedown="event.preventDefault()" onclick="applyPartialFontSize()" class="ml-1 text-xs text-gray-600 hover:text-blue-500 px-1" title="適用"><i class="fas fa-check"></i></button>
    </div>

    <div class="flex items-center gap-2 ml-auto">
        <a href="https://gemini.google.com/gem/1aQXlT177ks4j2LLC5ooZCyZV3xKGBIlx?usp=sharing" target="_blank" class="text-xs bg-indigo-50 text-indigo-700 border border-indigo-200 px-3 py-1 rounded hover:bg-indigo-100 transition flex items-center shadow-sm">
            <i class="fas fa-external-link-alt mr-2"></i> ルビを付けるGemを開く
        </a>
    </div>
</div>

<!-- メインエリア -->
<div class="flex flex-1 overflow-hidden">
    <!-- エディタ -->
    <div class="w-1/2 flex flex-col border-r border-gray-300 bg-gray-50">
        <div class="p-2 bg-gray-100 border-b text-xs font-bold text-gray-500 flex justify-between">
            <span>HTMLソース入力</span>
            <span class="text-gray-400">Geminiで作ったコードを貼り付け</span>
        </div>
        <textarea id="html-editor"
            class="flex-1 w-full p-4 resize-none focus:outline-none focus:ring-2 focus:ring-blue-300 text-gray-800 text-sm leading-relaxed font-mono"
            placeholder="<!-- ここにGemで生成したHTMLを貼り付けてください -->&#13;&#10;<ruby>漢字<rt>かんじ</rt></ruby>..."
            oninput="updatePreview()"></textarea>
    </div>

    <!-- プレビュー -->
    <div class="w-1/2 flex flex-col bg-gray-200 overflow-hidden" id="preview-scroller">
        <!-- プレビューヘッダー（モード切替付き） -->
        <div class="p-2 bg-gray-200/90 backdrop-blur border-b border-gray-300 flex justify-between items-center text-xs font-bold text-gray-500 shrink-0">
            <div class="flex items-center gap-2">
                <!-- プレビューモード切替 -->
                <button id="btn-mode-ruby" class="mode-btn active" onclick="setPreviewMode('ruby')">
                    <i class="fas fa-pen mr-1"></i>ルビ編集
                </button>
                <button id="btn-mode-web" class="mode-btn" onclick="setPreviewMode('web')">
                    <i class="fas fa-globe mr-1"></i>Webレンダリング
                </button>
                <!-- 編集モード切替（ルビ編集モード時のみ有効） -->
                <div class="ml-2 flex items-center gap-1 border-l pl-2">
                    <span id="edit-mode-indicator" class="mode-ruby">
                        <i class="fas fa-circle text-[6px]"></i> ルビ修正モード
                    </span>
                    <button id="btn-edit-toggle" onclick="toggleEditMode()" class="text-[10px] bg-white border border-gray-300 hover:bg-yellow-50 hover:border-yellow-400 px-2 py-0.5 rounded transition" title="テキスト直接編集モードに切り替え">
                        <i class="fas fa-exchange-alt mr-1"></i>切替
                    </button>
                </div>
            </div>
            <span id="preview-hint" class="text-gray-400">クリックでルビ修正 / 選択してボタンで装飾</span>
        </div>

        <div class="flex justify-center p-4 min-h-0 flex-1 overflow-y-auto" id="preview-scroll-inner">
            <!-- ルビ編集モード用コンテナ -->
            <div id="preview-container" class="page-hp preview-content ruby-edit-mode" spellcheck="false"></div>
            <!-- Webレンダリングモード用iframe -->
            <iframe id="web-iframe" class="hidden" sandbox="allow-same-origin allow-scripts"></iframe>
        </div>
    </div>
</div>

<!-- ルビ編集モーダル -->
<div id="ruby-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 w-96 shadow-xl relative">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg text-gray-700"><i class="fas fa-pen mr-2"></i>ルビ修正</h3>
            <span class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded">Enterで次へ</span>
        </div>
        <div class="flex gap-4 mb-6 items-end">
            <div class="flex-1">
                <label class="block text-xs text-gray-400 mb-1">漢字</label>
                <div id="modal-kanji-display" class="text-2xl font-bold text-center bg-gray-100 p-2 rounded text-gray-800"></div>
            </div>
            <div class="flex-1">
                <label class="block text-xs text-blue-500 font-bold mb-1">ふりがな</label>
                <input type="text" id="modal-ruby" class="w-full text-xl border-b-2 border-blue-500 p-2 focus:outline-none bg-transparent text-center" placeholder="読み" autocomplete="off">
            </div>
        </div>
        <div class="flex justify-between gap-2 mb-4">
            <button onclick="navigateRuby(-1)" class="flex-1 py-1 px-2 text-sm bg-gray-100 hover:bg-gray-200 rounded text-gray-600">
                <i class="fas fa-chevron-left mr-1"></i> 前へ
            </button>
            <button onclick="navigateRuby(1)" class="flex-1 py-1 px-2 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded font-bold">
                保存して次へ (Enter) <i class="fas fa-chevron-right ml-1"></i>
            </button>
        </div>
        <div class="flex justify-end pt-4 border-t gap-3">
            <button onclick="closeRubyModal()" class="text-gray-400 hover:text-gray-600 text-sm">閉じる</button>
            <button onclick="removeRubyTag()" class="text-red-400 hover:text-red-600 text-sm">ルビ解除</button>
        </div>
    </div>
</div>

<script>
    const editor = document.getElementById('html-editor');
    const preview = document.getElementById('preview-container');
    const baseFontSizeInput = document.getElementById('base-font-size');
    const selFontSizeInput = document.getElementById('sel-font-size');
    const webIframe = document.getElementById('web-iframe');
    const previewHint = document.getElementById('preview-hint');
    const editModeIndicator = document.getElementById('edit-mode-indicator');

    let currentTargetRuby = null;
    let lastRange = null;
    let currentMode = 'ruby'; // 'ruby' | 'web'
    let editMode = 'ruby'; // 'ruby' | 'text'

    window.addEventListener('DOMContentLoaded', () => {
        updateBaseFontSize();
        updatePreview();
    });

    // =====================
    // 編集モード切替（ルビ修正 ↔ テキスト直接編集）
    // =====================
    function toggleEditMode() {
        if (currentMode !== 'ruby') return;
        if (editMode === 'ruby') {
            setEditMode('text');
        } else {
            // テキスト編集モードから戻る際にエディタに同期
            syncPreviewToEditor();
            setEditMode('ruby');
        }
    }

    function setEditMode(mode) {
        editMode = mode;
        if (mode === 'text') {
            // テキスト直接編集モード
            preview.contentEditable = 'true';
            preview.classList.remove('ruby-edit-mode');
            preview.classList.add('text-edit-mode');
            editModeIndicator.innerHTML = '<i class="fas fa-circle text-[6px]"></i> テキスト編集モード';
            editModeIndicator.className = 'mode-text';
            document.getElementById('btn-edit-toggle').textContent = '← ルビ修正へ';
            previewHint.textContent = 'テキストを直接編集できます（Enterで改行）';
            // ruby clickを無効化
            preview.querySelectorAll('ruby').forEach(r => {
                r.onclick = null;
            });
            // contenteditable内での入力をエディタに反映
            preview.addEventListener('input', onPreviewDirectEdit);
        } else {
            // ルビ修正モード
            preview.contentEditable = 'false';
            preview.classList.add('ruby-edit-mode');
            preview.classList.remove('text-edit-mode');
            editModeIndicator.innerHTML = '<i class="fas fa-circle text-[6px]"></i> ルビ修正モード';
            editModeIndicator.className = 'mode-ruby';
            document.getElementById('btn-edit-toggle').innerHTML = '<i class="fas fa-exchange-alt mr-1"></i>切替';
            previewHint.textContent = 'クリックでルビ修正 / 選択してボタンで装飾';
            preview.removeEventListener('input', onPreviewDirectEdit);
            attachRubyClickEvents();
        }
    }

    function onPreviewDirectEdit() {
        // テキスト直接編集モード中にエディタをリアルタイム同期
        syncPreviewToEditorRaw();
    }

    // =====================
    // モード切替（ルビ編集 / Webレンダリング）
    // =====================
    function setPreviewMode(mode) {
        currentMode = mode;
        const btnRuby = document.getElementById('btn-mode-ruby');
        const btnWeb = document.getElementById('btn-mode-web');
        const editToggleArea = document.querySelector('#btn-edit-toggle').parentElement;

        if (mode === 'ruby') {
            btnRuby.classList.add('active');
            btnWeb.classList.remove('active');
            preview.classList.remove('hidden');
            webIframe.classList.add('hidden');
            editToggleArea.style.opacity = '1';
            editToggleArea.style.pointerEvents = 'auto';
            previewHint.textContent = editMode === 'text'
                ? 'テキストを直接編集できます（Enterで改行）'
                : 'クリックでルビ修正 / 選択してボタンで装飾';
            updatePreview();
        } else {
            btnWeb.classList.add('active');
            btnRuby.classList.remove('active');
            preview.classList.add('hidden');
            webIframe.classList.remove('hidden');
            editToggleArea.style.opacity = '0.4';
            editToggleArea.style.pointerEvents = 'none';
            previewHint.textContent = 'HTMLをそのまま表示（編集はルビ編集モードで）';
            updateWebIframe();
        }
    }

    function updateWebIframe() {
        const html = editor.value;
        const size = parseInt(baseFontSizeInput.value) || 12;
        const fullHtml = `<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<style>
  body {
    font-family: "BIZ UDPGothic","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;
    font-size: ${size}pt;
    line-height: 2.0;
    padding: 1.5rem;
    margin: 0;
    overflow-wrap: break-word;
  }
  table { border-collapse: collapse; margin: 0.5em 0; }
  th, td { border: 1px solid #999; padding: 4px 8px; }
  th { background: #f3f4f6; font-weight: bold; }
  ruby { display: inline-ruby; }
  rt { font-size: 0.5em; line-height: 1; color: #555; }
</style>
</head>
<body>${html}</body>
</html>`;
        webIframe.srcdoc = fullHtml;
    }

    // =====================
    // 新しいタブで全画面表示
    // =====================
    function openInNewTab() {
        const html = editor.value;
        const size = parseInt(baseFontSizeInput.value) || 12;
        const fullHtml = `<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ルビふりお2 - プレビュー</title>
<style>
  body {
    font-family: "BIZ UDPGothic","BIZ UDGothic","Hiragino Kaku Gothic ProN","Hiragino Sans","Meiryo","Yu Gothic",sans-serif;
    font-size: ${size}pt;
    line-height: 2.0;
    padding: 2rem;
    margin: 0;
    overflow-wrap: break-word;
    background: white;
  }
  table { border-collapse: collapse; margin: 0.5em 0; }
  th, td { border: 1px solid #999; padding: 4px 8px; }
  th { background: #f3f4f6; font-weight: bold; }
  ruby { display: inline-ruby; }
  rt { font-size: 0.5em; line-height: 1; color: #555; text-align: center; }
</style>
</head>
<body>${html}</body>
</html>`;
        const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        window.open(url, '_blank');
        // 少し待ってからURLを解放
        setTimeout(() => URL.revokeObjectURL(url), 10000);
    }

    // =====================
    // 選択範囲の記憶
    // =====================
    function capturePreviewSelectionRange() {
        if (editMode === 'text') return; // テキスト編集中はスキップ
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        const r = sel.getRangeAt(0);
        if (!r.collapsed && preview.contains(r.commonAncestorContainer)) {
            lastRange = r.cloneRange();
        }
    }

    document.addEventListener('selectionchange', () => {
        capturePreviewSelectionRange();
    });

    ['pointerdown', 'mousedown', 'touchstart'].forEach(evt => {
        selFontSizeInput.addEventListener(evt, () => {
            capturePreviewSelectionRange();
        }, { passive: true });
    });

    // =====================
    // プレビュー更新
    // =====================
    function updatePreview() {
        if (currentMode === 'web') {
            updateWebIframe();
            return;
        }

        // テキスト編集モード中はエディタからの更新をしない（直接編集優先）
        if (editMode === 'text') return;

        const rawText = editor.value;
        const htmlContent = smartBrConvert(rawText);
        preview.innerHTML = htmlContent;
        attachRubyClickEvents();
    }

    /**
     * <br>変換の改善版:
     * <table>〜</table> や <pre>〜</pre> の中にある \n は <br> に変換しない。
     */
    function smartBrConvert(html) {
        const PRESERVE_TAGS = ['table', 'pre', 'ol', 'ul', 'dl', 'style', 'script'];
        const pattern = new RegExp(
            `(<(?:${PRESERVE_TAGS.join('|')})[^>]*>[\\s\\S]*?</(?:${PRESERVE_TAGS.join('|')})>)`,
            'gi'
        );

        const blocks = [];
        let processed = html.replace(pattern, (match) => {
            const idx = blocks.length;
            blocks.push(match);
            return `\x00BLOCK${idx}\x00`;
        });

        processed = processed.replace(/\n/g, '<br>');

        processed = processed.replace(/\x00BLOCK(\d+)\x00/g, (_, idx) => blocks[parseInt(idx)]);

        return processed;
    }

    function updateBaseFontSize() {
        let size = parseInt(baseFontSizeInput.value) || 12;
        preview.style.fontSize = size + 'pt';
        if (currentMode === 'web') updateWebIframe();
    }
    function stepFontSize(amount) {
        let current = parseInt(baseFontSizeInput.value) || 12;
        let next = Math.max(6, current + amount);
        baseFontSizeInput.value = next;
        updateBaseFontSize();
    }

    function changeLayout() {
        const type = document.getElementById('layout-select').value;
        preview.className = `preview-content ruby-edit-mode ${type === 'a4' ? 'page-a4' : 'page-hp'}`;
    }

    // =====================
    // =====================
    function applyStyleToSelection(startTag, endTag) {
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && preview.contains(selection.anchorNode)) {
            applyStyleToPreview(startTag, endTag, selection.getRangeAt(0));
        } else if (lastRange && preview.contains(lastRange.commonAncestorContainer)) {
            applyStyleToPreview(startTag, endTag, lastRange);
        } else {
            insertTagToEditor(startTag, endTag);
        }
    }

    function applyStyleToPreview(startTag, endTag, range) {
        if (!range || range.collapsed) return;
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = startTag + 'dummy' + endTag;
        const wrapper = tempDiv.firstElementChild;
        if (wrapper) {
            try {
                const liveRange = range.cloneRange();
                const content = liveRange.extractContents();
                wrapper.innerHTML = "";
                wrapper.appendChild(content);
                liveRange.insertNode(wrapper);
                syncPreviewToEditor();
                const newRange = document.createRange();
                newRange.selectNodeContents(wrapper);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(newRange);
                lastRange = newRange.cloneRange();
            } catch (e) {
                console.error("Selection wrap failed:", e);
                alert("その選択範囲には適用できませんでした（タグ構造が複雑な可能性があります）");
            }
        }
    }

    function insertTagToEditor(startTag, endTag) {
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const text = editor.value;
        editor.value = text.substring(0, start) + startTag + text.substring(start, end) + endTag + text.substring(end);
        editor.focus();
        editor.selectionStart = start + startTag.length;
        editor.selectionEnd = end + startTag.length;
        updatePreview();
    }

    function wrapSelection(tag) { applyStyleToSelection(`<${tag}>`, `</${tag}>`); }
    function wrapColor(color) { applyStyleToSelection(`<span style="color:${color}">`, `</span>`); }
    function wrapFontFamily(font) {
        if (font === "") return;
        applyStyleToSelection(`<span style="font-family:${font}">`, `</span>`);
    }

    function applyPartialFontSize() {
        const size = parseInt(selFontSizeInput.value);
        if (!size || size < 6) return;
        applyStyleToSelection(`<span style="font-size:${size}pt">`, `</span>`);
    }

    function applyPartialFontSizeStep(amount) {
        capturePreviewSelectionRange();
        let current = parseInt(selFontSizeInput.value) || 16;
        let next = Math.max(6, current + amount);
        selFontSizeInput.value = next;
        applyPartialFontSize();
    }

    // =====================
    // ルビ機能
    // =====================
    function attachRubyClickEvents() {
        preview.querySelectorAll('ruby').forEach(ruby => {
            ruby.onclick = (e) => { e.stopPropagation(); openRubyModal(ruby); };
            ruby.title = "修正する";
        });
    }

    const modal = document.getElementById('ruby-modal');
    const modalKanjiDisplay = document.getElementById('modal-kanji-display');
    const modalRuby = document.getElementById('modal-ruby');

    function openRubyModal(rubyElement) {
        if (editMode !== 'ruby') return; // テキスト編集モード中は開かない
        if (currentTargetRuby) currentTargetRuby.classList.remove('editing-active');
        currentTargetRuby = rubyElement;
        currentTargetRuby.classList.add('editing-active');
        let kanjiText = "";
        rubyElement.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) kanjiText += node.textContent;
        });
        const rt = rubyElement.querySelector('rt');
        modalKanjiDisplay.textContent = kanjiText;
        modalRuby.value = rt ? rt.textContent : "";
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        modalRuby.focus();
    }

    function closeRubyModal() {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        if (currentTargetRuby) {
            currentTargetRuby.classList.remove('editing-active');
            currentTargetRuby = null;
        }
    }

    function saveRubyAndStay() {
        if (!currentTargetRuby) return;
        const rt = currentTargetRuby.querySelector('rt');
        if (rt) rt.textContent = modalRuby.value;
        syncPreviewToEditor();
    }

    function navigateRuby(direction) {
        if (!currentTargetRuby) return;
        saveRubyAndStay();
        const allRubies = Array.from(preview.querySelectorAll('ruby'));
        const nextIndex = allRubies.indexOf(currentTargetRuby) + direction;
        if (nextIndex >= 0 && nextIndex < allRubies.length) {
            openRubyModal(allRubies[nextIndex]);
        } else {
            closeRubyModal();
        }
    }

    function removeRubyTag() {
        if (!currentTargetRuby) return;
        let kanjiText = "";
        currentTargetRuby.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) kanjiText += node.textContent;
        });
        currentTargetRuby.parentNode.replaceChild(document.createTextNode(kanjiText), currentTargetRuby);
        syncPreviewToEditor();
        closeRubyModal();
    }

    // =====================
    // プレビュー → エディタ同期
    // =====================
    function syncPreviewToEditor() {
        const clone = preview.cloneNode(true);

        // テーブル外の <br> だけ \n に変換
        clone.querySelectorAll('table br').forEach(br => {
            br.replaceWith(document.createTextNode('\x00TDBR\x00'));
        });

        clone.querySelectorAll('br').forEach(br => {
            br.replaceWith(document.createTextNode('\n'));
        });

        let html = clone.innerHTML;
        html = html.replace(/\x00TDBR\x00/g, '<br>');

        editor.value = html;
    }

    // テキスト直接編集モード用の同期（contentEditableのinnerHTMLをそのまま取得）
    function syncPreviewToEditorRaw() {
        const clone = preview.cloneNode(true);

        // テーブル外のbrのみ\nに
        clone.querySelectorAll('table br').forEach(br => {
            br.replaceWith(document.createTextNode('\x00TDBR\x00'));
        });
        clone.querySelectorAll('br').forEach(br => {
            br.replaceWith(document.createTextNode('\n'));
        });
        // divタグ（contentEditableが挿入するもの）を改行に
        clone.querySelectorAll('div').forEach(div => {
            div.insertAdjacentText('afterbegin', '\n');
            div.replaceWith(...div.childNodes);
        });

        let html = clone.innerHTML;
        html = html.replace(/\x00TDBR\x00/g, '<br>');

        editor.value = html;
    }

    function copyHtml() {
        navigator.clipboard.writeText(editor.value).then(() => alert('コピーしました'));
    }

    modal.addEventListener('click', (e) => { if (e.target === modal) closeRubyModal(); });
    modalRuby.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); navigateRuby(1); }
    });

    selFontSizeInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            capturePreviewSelectionRange();
            applyPartialFontSize();
        }
    });
</script>
</body>
</html>
このコードで、画像を貼り付けられるようにしたい。
画像はネット上にあるもの、googleドキュメントに保存してあるもの、がある。どうしたらいいでしょう？
